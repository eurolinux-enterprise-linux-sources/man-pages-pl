.\" 1999 PTM Przemek Borys
.\" Aktualizacja do man-pages 1.47 - A. Krzysztofowicz <ankry@mif.pg.gda.pl>
.\" --------
.\" Copyright (c) 1990, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" the American National Standards Committee X3, on Information
.\" Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)stdarg.3	6.8 (Berkeley) 6/29/91
.\"
.\" Converted for Linux, Mon Nov 29 15:11:11 1993, faith@cs.unc.edu
.\" Additions, 2001-10-14, aeb
.\" --------
.TH STDARG 3 2001-10-14 "" "Podrêcznik programisty Linuksa"
.SH NAZWA
stdarg \- listy zmiennych argumentów
.SH SK£ADNIA
.B #include <stdarg.h>
.sp
.BI "void va_start(va_list " ap ", " last );
.br
.BI "" type " va_arg(va_list " ap ", " type );
.br
.BI "void va_end(va_list " ap );
.br
.BI "void va_copy(va_list " dest ", va_list " src );
.SH OPIS
Funkcjê mo¿na wo³aæ z ró¿n± liczb± argumentów, ró¿nych typów. Plik
nag³ówkowy
.I stdarg.h
deklaruje typ
.B va_list
i definiuje trzy makra, iteruj±ce poprzez listê argumentów, których liczba i
typy nie s± znane wywo³anej funkcji.
.PP
Wywo³ana funkcja musi zadeklarowaæ obiekt typu
.BR va_list ,
który jest u¿ywany przez makra
.BR va_start ,
.BR va_arg 
i
.BR va_end .
.SS va_start
Makro
.B va_start
inicjuje
.I ap
do dalszego u¿ytku przez
.B va_arg
i
.BR va_end ,
i musi byæ wywo³ane jako pierwsze.
.PP
Parametr
.I last
jest nazw± ostatniego parametru przed zmienn± list± argumentów, czyli ostatnim
parametrem, którego typ by³ funkcji znany.
.PP
Poniewa¿ adres tego parametru jest u¿ywany w makrze
.BR va_start ,
nie powinien on byæ deklarowany jako zmienna rejestrowa, funkcja czy typ
tablicowy.
.SS va_arg
Makro
.B va_arg
rozwija siê do wyra¿enia, które ma typ i warto¶æ nastêpnego argumentu w
wywo³aniu. Parametr
.I ap
to
.B va_list
.I ap
zainicjowany przez
.BR va_start .
Ka¿de wywo³anie
.B va_arg
zmienia
.I ap
tak, ¿e nastêpne wywo³anie zwraca nastêpny argument. Parametr
.I type
Jest nazw± typu, podan± tak ¿e typ wska¼nika do obiektu, który ma podany typ
mo¿na uzyskaæ przez dodanie * do
.IR type .
.PP
Pierwsze u¿ycie makra
.B va_arg
po
.B va_start
zwraca argument za
.IR last (ostatnim).
Kolejne wywo³ania zwracaj± warto¶ci pozosta³ych argumentów.
.PP
Je¶li nie ma nastêpnego argumentu lub je¶li
.I type
nie jest zgodny z rzeczywistym typem nastêpnego argumentu, pojawi± siê
losowe b³êdy.
.PP
Je¶li
.I ap
zostanie przekazane do funkcji u¿ywaj±cej
.BI va_arg( ap , type )\fP,
to warto¶æ
.I ap
po zakoñczeniu tej funkcji bêdzie nieokre¶lona.
.SS va_end
Ka¿demu wywo³aniu
.B va_start
musi odpowiadaæ wywo³anie
.B va_end
w obrêbie tej samej funkcji. Po wywo³aniu
.BI va_end( ap )
warto¶æ
.I ap
bêdzie nieokre¶lona. Lista mo¿e byæ przetwarzana wielokrotnie, przy czym
.\" transversal of the list  ->  przetworzenie listy ?
ka¿de przetworzenie musi byæ zawarte pomiêdzy
.B va_start
a
.BR va_end .
.B va_end
mo¿e byæ zarówno makrem, jak i funkcj±.
.SS va_copy
.\" Proposal from clive@demon.net, 1997-02-28
Oczywista implementacja zawiera³aby wska¼nik
.B va_list
do ramki stosu funkcji o zmiennej liczbie argumentów.
Przy takiej konfiguracji (jak dot±d, najpowszechniejszej) nie ma ¿adnych
przeciwskazañ wobec podstawienia
.RS
.nf
        va_list aq = ap;
.fi
.RE
Niestety, s± równie¿ systemy, które robi± to poprzez tablicê wska¼ników
(o d³ugo¶ci 1) i wtedy niezbêdne jest
.RS
.nf
        va_list aq;
        *aq = *ap;
.fi
.RE
Wreszcie, w systemach, które przekazuj± parametry w rejestrach, mo¿e okazaæ
siê koniecznym przydzielenie pamiêci przez
.BR va_start ,
przechowanie tam parametrów, jak te¿ wskazañ, który parametr jest nastêpny,
tak aby
.B va_arg
mog³o przej¶æ ca³± listê. Wówczas
.B va_end
mo¿e wreszcie zwolniæ przydzielon± w tym celu pamiêæ.
Aby dostosowaæ siê do tej sytuacji, C99 dodaje makro
.BR va_copy ,
tak aby powy¿sze przypisanie mog³o byc zast±pione przez
.RS
.nf
        va_list aq;
        va_copy(aq, ap);
        ...
        va_end(aq);
.fi
.RE
Ka¿demu wywo³aniu
.B va_copy
musi odpowiadaæ wywo³anie
.B va_end
w obrêbie tej samej funkcji.
Niektóre systemy nie udostêpniaj±ce
.B va_copy
posiadaj± zamiast tego
.BR __va_copy ,
gdy¿ ta nazwa by³a u¿ywana w szkicowej propozycji standardu.
.SH PRZYK£ADY
Funkcja
.I foo
pobiera ³añcuch znaków formatuj±cych i wypisuje argumenty z nimi zwi±zane
w oparciu o typ argumentu. 
.RS
.nf
#include <stdio.h>
#include <stdarg.h>

void foo(char *fmt, ...) {
	va_list ap;
	int d;
	char c, *p, *s;

	va_start(ap, fmt);
	while (*fmt)
		switch(*fmt++) {
		case 's':			/* napis */
			s = va_arg(ap, char *);
			printf("string %s\en", s);
			break;
		case 'd':			/* int */
			d = va_arg(ap, int);
			printf("int %d\en", d);
			break;
		case 'c':			/* char */
                        /* wystêpuje tu potrzeba rzutowania, gdy¿ va_arg
                           pobiera w pe³ni awansowane typy */
.\" W oryginale: fully promoted types
			c = (char) va_arg(ap, int);
			printf("char %c\en", c);
			break;
		}
	va_end(ap);
}
.fi
.RE
.SH "ZGODNE Z"
Makra
.BR va_start ,
.BR va_arg ,
i
.B va_end
s± zgodne z ANSI X3.159-1989 (``C89'').
C99 definiuje makro
.BR va_copy .
.SH KOMPATYBILNO¦Æ
Makra te
.I nie
s± zgodne z historycznymi makrami, które zast±pi³y. Zgodna wstecznie wersja
znajduje siê w pliku nag³ówkowym
.IR varargs.h .
.SH PORÓWNANIE
Historyczna konfiguracja to:
.RS
.nf
#include <varargs.h>

void foo(va_alist) va_dcl {
        va_list ap;

        va_start(ap);
        while(...) {
                ...
                x = va_arg(ap, type);
                ...
        }
        va_end(ap);
}
.fi
.RE
W niektórych systemach,
.I va_end
zawiera zamykaj±cy '}' odpowiadaj±cy '{' w
.IR va_start ,
tak ¿eby obydwa makra musia³y wyst±piæ w tej samej funkcji w dozwolony sposób.
.SH USTERKI
W przeciwieñstwie do makr
.BR varargs ,
makra
.B stdarg
nie zezwalaj± programistom na tworzenie funkcji bez ustalonych argumentów.
Problem ten powoduje utrudnienia podczas konwersji kodu 
.B varargs
na kod
.BR stdarg ,
a tak¿e utrudnia tworzenie funkcji, które maj± za zadanie jedynie przekazaæ
wszystkie swoje argumenty do funkcji pobieraj±cej argument
.BR va_list ,
takiej jak
.BR vfprintf (3).
