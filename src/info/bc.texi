%& -translate-file=il2-pl
\def\fontprefix{pl}
\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename bc.info
@settitle Podrêcznik polecenia bc
@documentencoding ISO-8859-2
@documentlanguage pl
@c %**end of header

@c This file has the new style title page commands.
@c Run `makeinfo' rather than `texinfo-format-buffer'.

@smallbook

@c tex
@c \overfullrule=0pt
@c end tex

@titlepage
@title bc, jêzyk kalkulatora dowolnej precyzji
@subtitle wersja 1.06

@author Philip A. Nelson
@page
@ifinfo
@direntry
* bc: (bc).                   Jêzyk kalkulatora dowolnej precyzji.
@end direntry
@end ifinfo
Niniejszy podrêcznik opisuje @code{bc}, jêzyk kalkulatora dowolnej
precyzji.

Jest on czê¶ci± GNU @code{bc}.@*
@sp4
Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@iftex
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
@end iftex

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.

Z autorem mo¿na skontaktowaæ siê pod adresem:
e-mail: @email{phil@@cs.wwu.edu}@*
us-mail: Philip A. Nelson@*
Computer Science Department, 9062@*
Western Washington University@*
Bellingham, WA 98226-9062

@end titlepage

@node Top, Od t³umacza, (dir), (dir)

@menu
* Od t³umacza::
* Wprowadzenie::
* Podstawowe elementy::
* Wyra¿enia::
* Instrukcje::
* Funkcje::
* Przyk³ady::
* Opcje Readline i Libedit::
* GNU bc a inne implementacje::
* Ograniczenia::
* Zmienne ¶rodowiska::
* Zg³aszanie b³êdów::
@end menu

@node Od t³umacza, Wprowadzenie, Top, Top
@comment  node-name,  next,  previous,  up
@unnumbered Od t³umacza
Niniejszy przek³ad powsta³ w ramach Projektu T³umaczenia Manuali
(@uref{http://ptm.linux.pl/, http://ptm.linux.pl/}).  Zg³oszenia b³êdów,
komentarze i sugestie proszê przesy³aæ na listê dyskusyjn± Projektu:
@email{ptm@@amg.net.pl} lub ewentualnie do autora t³umaczenia.

W.Kotwica (@email{wkotwica@@post.pl})

@unnumberedsec Rozpowszechnianie
To jest nieoficjalne t³umaczenie warunków rozpowszechniania na jêzyk polski.
Nie zosta³o ono opublikowane przez Free Software Foundation
i pod wzglêdem prawnym nie stanowi warunków rozpowszechniania -- ustanawia
je wy³±cznie oryginalny tekst angielski.  Jednak t³umacz ma nadziejê, ¿e
pomo¿e ono lepiej zrozumieæ warunki rozpowszechniania osobom mówi±cym
po polsku.

This is an unofficial translation of the distribution terms into
Polish language. It was not published by the Free Software Foundation, and
does not legally state the distribution terms--only the original English text
does that. However, the translator hopes that it will help Polish language
speakers understand distribution terms better.

Zezwala siê na tworzenie i rozpowszechnianie wiernych kopii
tego podrêcznika, pod warunkiem, ¿e na wszystkich kopiach zostanie zachowana
informacja o prawach autorskich i niniejsze zezwolenie.

Zezwala siê na kopiowanie i rozpowszechnianie zmienionych wersji
tego podrêcznika na warunkach jak dla wiernych kopii, pod warunkiem, ¿e
ca³a praca pochodna bêdzie rozpowszechniana na warunkach zezwolenia
identycznego jak niniejsze.

Zezwala siê na kopiowanie i rozpowszechnianie t³umaczeñ tego
podrêcznika na inny jêzyk, pod wy¿ej podanymi warunkami dla zmienionych
wersji, z wyj±tkiem tego, ¿e niniejsze zezwolenie mo¿e byæ ustanowione
w t³umaczeniu zaakceptowanym przez Fundacjê.

@node Wprowadzenie, Podstawowe elementy, Od t³umacza, Top
@chapter Wprowadzenie
@menu
* Opis::
* Opcje wiersza poleceñ::
@end menu

@node Opis, Opcje wiersza poleceñ, Wprowadzenie, Wprowadzenie
@section Opis

@code{bc} [ -hlwsqv ] [d³ugie_opcje] [ @var{ plik ...} ]

@code{bc} jest jêzykiem obs³uguj±cym obliczenia na liczbach dowolnej
dok³adno¶ci z interaktywnym wykonywaniem instrukcji. Istniej± pewne
podobieñstwa sk³adni do jêzyka programowania C. Przy pomocy opcji wiersza
poleceñ dostêpna jest standardowa biblioteka matematyczna. Na ¿±danie,
biblioteka matematyczna jest definiowana przed rozpoczêciem przetwarzania
plików. @code{bc} rozpoczyna pracê przetwarzaj±c kod z wszystkich plików
wymienionych w wierszu poleceñ, zachowuj±c ich kolejno¶æ. Po przetworzeniu
wszystkich plików, @code{bc} czyta ze standardowego wej¶cia. Ca³o¶æ kodu
wykonywana jest w miarê czytania. (Je¶li plik zawiera polecenie zatrzymania
procesora, to @code{bc} nie bêdzie prowadzi³ odczytu ze standardowego
wej¶cia.)

Omawiana wersja @code{bc} zawiera kilka rozszerzeñ w stosunku do
tradycyjnych realizacji @code{bc} i standardu POSIX.
Opcje wiersza poleceñ mog± powodowaæ, ¿e rozszerzenia te bêd± wy¶wietlaæ
ostrze¿enia lub bêd± odrzucane. Niniejszy dokument opisuje jêzyk akceptowany
przez ten procesor bc. Rozszerzenia s± w nim wyra¼nie wyró¿nione.

Autor chcia³by podziêkowaæ Steve'owi Sommars
(@email{Steve.Sommars@@att.com}) za jego szerok± pomoc w testowaniu tej
implementacji. Podsun±³ on wiele cennych sugestii. Dziêki jego zaanga¿owaniu
jest to o wiele lepszy produkt.

@node Opcje wiersza poleceñ, Liczby, Opis, Wprowadzenie
@section Opcje wiersza poleceñ

@code{bc} pobiera z wiersza poleceñ nastêpuj±ce opcje:
@table @code

@item -h, --help
Wypisuje informacjê o sposobie wywo³ania i koñczy dzia³anie.

@item -i, --interactive
Wymusza tryb interaktywny.

@item -l, --mathlib
Definiuje standardow± bibliotekê matematyczn±.

@item -w, --warn
Ostrzega o rozszerzeniach w stosunku do POSIX @code{bc}.

@item -s, --standard
Przetwarza wy³±cznie standardowy, POSIX-owy jêzyk @code{bc}.

@item -q, --quiet
Nie wy¶wietla zwyk³ego przywitania GNU @code{bc}.

@item -v, --version
Wypisuje numer wersji, informacjê o prawach autorskich i koñczy dzia³anie.

@end table


@node Podstawowe elementy, Wyra¿enia, Wprowadzenie, Top
@chapter Podstawowe elementy
@menu
* Liczby::
* Zmienne::
* Komentarze::
@end menu

@node Liczby, Zmienne, Opcje wiersza poleceñ, Podstawowe elementy
@section Liczby

Najbardziej podstawowym elementem w @code{bc} jest liczba. Liczby s±
liczbami dowolnej dok³adno¶ci. Dok³adno¶æ ta odnosi siê zarówno do czê¶ci
ca³kowitej jak i do u³amkowej. Wszystkie liczby s± reprezentowane
wewnêtrznie w postaci dziesiêtnej i wszystkie obliczenia prowadzone s± w
uk³adzie dziesiêtnym.  (Opisywana wersja obcina wyniki operacji dzielenia i
mno¿enia.) Liczby posiadaj± dwa atrybuty: d³ugo¶æ i dok³adno¶æ.  [od t³um.:
(org.scale) - w t³umaczeniu u¿ywane bêdzie s³owo ``dok³adno¶æ'' w znaczeniu
zbli¿onym do znanego np. z obs³ugi kalkulatorów] D³ugo¶æ jest ca³kowit±
liczb± cyfr znacz±cych liczby, za¶ dok³adno¶æ jest ca³kowit± liczb± cyfr
dziesiêtnych po kropce dziesiêtnej.  Na przyk³ad, .000001 ma d³ugo¶æ 6 i
dok³adno¶æ 6, za¶ 1935.000 ma d³ugo¶æ 7 i dok³adno¶æ 3.

@node Zmienne, Komentarze, Liczby, Podstawowe elementy
@section Zmienne

Liczby przechowywane s± w dwu rodzajach zmiennych, zmiennych prostych
i tablicach. Zarówno zmienne proste jak i tablice posiadaj± nazwy. Nazwy
zaczynaj± siê od litery, po której nastêpuje dowolna liczba liter, cyfr
i znaków podkre¶lenia. Wszystkie litery musz± byæ ma³e. (Nazwy w pe³ni
alfanumeryczne s± rozszerzeniem. W POSIX-owym @code{bc} wszystkie nazwy s±
pojedynczymi ma³ymi literami.) Rodzaj zmiennej wynika z kontekstu, gdy¿
po nazwie ka¿dej zmiennej tablicowej wyst±pi± nawiasy kwadratowe ([]).

Istniej± cztery zmienne specjalne: @var{scale}, @var{ibase}, @var{obase}
oraz @var{last}. @var{scale} okre¶la, jak niektóre operacje u¿ywaj± cyfr po
kropce dziesiêtnej. Domy¶ln± warto¶ci± @var{scale} jest 0. @var{ibase}
oraz @var{obase} okre¶laj± podstawê pozycyjnego systemu liczbowego przy
konwersji wej¶cia i wyj¶cia. Domy¶ln± podstaw± zarówno dla wej¶cia jak i dla
wyj¶cia jest 10. @var{last} (rozszerzenie standardu) jest zmienn±, która
przechowuje warto¶æ ostatnio wydrukowanej liczby. Zmienne te bêd± omówione
szczegó³owo pó¼niej, w odpowiedniej czê¶ci. Wszystkie z nich mog± mieæ
przypisywane warto¶ci, jak równie¿ mog± byæ u¿ywane w wyra¿eniach.

@node Komentarze, , Zmienne, Podstawowe elementy
@section Komentarze

Komentarze w @code{bc} rozpoczynaj± siê od znaków @code{/*} za¶ koñcz±
znakami @code{*/}. Komentarze mog± zaczynaæ siê w dowolnym miejscu i na
wej¶ciu pojawiaj± siê jako pojedyncze spacje. (Powoduje to, ¿e komentarze s±
ogranicznikami innych elementów wej¶cia. Na przyk³ad, komentarz nie mo¿e
znajdowaæ siê w ¶rodku nazwy zmiennej.) Komentarze obejmuj± znaki nowej
linii (koñca linii) pomiêdzy pocz±tkiem a koñcem komentarza.

Do zapewnienia obs³ugi skryptów dla @code{bc}, jako rozszerzenie dodano
komentarz w pojedynczym wierszu. Komentarz jednowierszowy rozpoczyna siê
znakiem @code{#} i rozci±ga siê do koñca wiersza. Znak koñca linii nie jest
tu czê¶ci± komentarza i jest przetwarzany jak zwykle.

@node Wyra¿enia, Instrukcje, Podstawowe elementy, Top
@chapter Wyra¿enia

@menu
* O wyra¿eniach i zmiennych specjalnych::
* Podstawowe wyra¿enia::
* Wyra¿enia relacyjne::
* Wyra¿enia logiczne::
* Priorytet::
* Wyra¿enia specjalne::
@end menu

@node O wyra¿eniach i zmiennych specjalnych, Podstawowe wyra¿enia, Wyra¿enia, Wyra¿enia
@section O wyra¿eniach i zmiennych specjalnych

Liczbami pos³uguj± siê wyra¿enia i instrukcje. Poniewa¿ jêzyk zosta³
zaprojektowany jako interaktywny, instrukcje i wyra¿enia wykonywane s±
niezw³ocznie. Nie ma ¿adnego programu "g³ównego". Zamiast tego, kod
jest wykonywany zaraz po jego napotkaniu. (Funkcje, omówione szczegó³owo
dalej, s± zdefiniowane po ich napotkaniu.)

Proste wyra¿enie jest po prostu sta³±. @code{bc} zamienia sta³e na wewnêtrzne
liczby dziesiêtne przy u¿yciu bie¿±cej podstawy systemu dla wprowadzania,
podanej w zmiennej @var{ibase}. (Istnieje wyj±tek dla funkcji.)
Dopuszczalnymi warto¶ciami @var{ibase} s± 2 do 16. Przypisanie @var{ibase}
warto¶ci spoza tego zakresu nada jej warto¶æ 2 lub 16. Liczby wej¶ciowe mog±
zawieraæ znaki 0-9 oraz A-F. (Uwaga: musz± to byæ wielkie litery. Ma³e
litery s± nazwami zmiennych.) Liczby jednocyfrowe maj± zawsze warto¶æ cyfry,
bez wzglêdu na warto¶æ @var{ibase}. (tj. A = 10.) Dla liczb wielocyfrowych
@code{bc} zamienia wszystkie cyfry wej¶ciowe wiêksze b±d¼ równe
@var{ibase} na warto¶æ @var{ibase}-1. Powoduje to, ¿e liczba @code{FFF}
bêdzie zawsze najwiêksz± trzycyfrow± liczb± przy danej podstawie systemu dla
wej¶cia.

Pe³ne wyra¿enia s± podobne do wystêpuj±cych w wielu jêzykach wysokiego
poziomu. Poniewa¿ wystêpuje tylko jeden rodzaj liczb, nie ma regu³
okre¶laj±cych u¿ycie ró¿nych typów. Zamiast tego istniej± regu³y dotycz±ce
dok³adno¶ci wyra¿eñ. Ka¿de wyra¿enie posiada okre¶lon± dok³adno¶æ. Zale¿y
ona od dok³adno¶ci pierwotnych liczb, wykonywanego dzia³ania i, w wielu
przypadkach, warto¶ci zmiennej @var{scale}. Dopuszczalnymi warto¶ciami
zmiennej @var{scale} s± liczby od 0 a¿ do maksymalnej liczby, jaka mo¿e byæ
reprezentowana jako ca³kowita (integer) w jêzyku C.

@node Podstawowe wyra¿enia, Wyra¿enia relacyjne, O wyra¿eniach i zmiennych specjalnych, Wyra¿enia
@section Podstawowe wyra¿enia

W podanych poni¿ej opisach dopuszczalnych wyra¿eñ, "wyra¿enie" okre¶la
pe³ne wyra¿enie a "@var{zmn}" okre¶la zmienn± prost± lub tablicow±.
Zmienn± prost± jest po prostu

@var{nazwa}

a zmienna tablicowa jest okre¶lona jako

@var{nazwa}[@var{wyra¿enie}]

Dok³adno¶æ wyniku jest maksymaln± z dok³adno¶ci u¿ytych w nim wyra¿eñ, chyba
¿e podano inaczej.

@table @code
@item - wyra¿enie
Wynikiem jest warto¶æ przeciwna do wyra¿enia.

@item ++ @var{zmn}
Zmienna jest powiêkszana o jeden a wynikiem wyra¿enia jest ta nowa warto¶æ.

@item -- @var{zmn}
Zmienna jest pomniejszana o jeden a wynikiem wyra¿enia jest ta nowa warto¶æ.

@item @var{zmn} ++
Wynikiem wyra¿enia jest warto¶æ zmiennej, a nastêpnie zmienna jest
powiêkszana o jeden.

@item @var{zmn} --
Wynikiem wyra¿enia jest warto¶æ zmiennej, a nastêpnie zmienna jest
pomniejszana o jeden.

@item wyra¿enie - wyra¿enie
Wynikiem tego wyra¿enia jest suma obu wyra¿eñ.

@item wyra¿enie - wyra¿enie
Wynikiem tego wyra¿enia jest ró¿nica obu wyra¿eñ.

@item wyra¿enie * wyra¿enie
Wynikiem tego wyra¿enia jest iloczyn obu wyra¿eñ.

@item wyra¿enie / wyra¿enie
Wynikiem tego wyra¿enia jest iloraz obu wyra¿eñ. Liczba cyfr po kropce
dziesiêtnej wyniku jest równa warto¶ci zmiennej @code{scale}.

@item wyra¿enie % wyra¿enie
Wynikiem tego wyra¿enia jest "reszta" z dzielenia obliczana w nastêpuj±cy
sposób. W celu obliczenia a%b, obliczane jest najpierw a/b z dok³adno¶ci± do
@var{scale} cyfr dziesiêtnych. Wynik u¿ywany jest do obliczenia
a-(a/b)*b z dok³adno¶ci± okre¶lon± jako maksymalna z @var{scale}+scale(b)
oraz scale(a).  Je¿eli zmienna @var{scale} ustawiona jest na zero, za¶ oba
wyra¿enia s± ca³kowite to wyra¿enie to jest funkcj± reszty ca³kowitej.

@item wyra¿enie ^ wyra¿enie
Wynikiem tego wyra¿enia jest warto¶æ pierwszego z wyra¿eñ podniesiona do
potêgi okre¶lonej przez drugie. Drugie wyra¿enie musi byæ liczb± ca³kowit±.
(Je¶li drugie wyra¿enie nie jest ca³kowite, to emitowane jest ostrze¿enie a
wyra¿enie jest obcinane tak, by otrzymaæ warto¶æ ca³kowit±). Liczba cyfr
u³amkowych wyniku wynosi @var{scale}, je¶li wyk³adnik jest ujemny. Je¿eli
jest on dodatni, to dok³adno¶æ (liczba cyfr po kropce dziesiêtnej) wyniku
stanowi minimum z dok³adno¶ci pierwszego wyra¿enia przemno¿onej przez
warto¶æ wyk³adnika i maksimum z @var{scale} i dok³adno¶ci pierwszego
wyra¿enia. To znaczy:
@example
scale(a^b) = min(scale(a)*b, max(@var{scale}, scale(a))).
@end example
Nale¿y pamiêtaæ, ¿e wyra¿enie^0 zawsze zwraca warto¶æ 1.

@item ( wyra¿enie )
Nawiasy wymuszaj± zmianê standardowych priorytetów przy obliczaniu
wyra¿enia.

@item @var{zmn} = wyra¿enie
Zmiennej przypisywana jest warto¶æ wyra¿enia.

@item @var{zmn} <op>= wyra¿enie
jest to równowa¿ne zapisowi "@var{zmn} = @var{zmn} <op> wyra¿enie",
z wyj±tkiem tego, i¿ czê¶æ "@var{zmn}" jest wyliczana tylko raz. Mo¿e to
byæ istotne, je¶li "@var{zmn}" jest tablic±.
@end table

@node Wyra¿enia relacyjne, Wyra¿enia logiczne, Podstawowe wyra¿enia, Wyra¿enia
@section Wyra¿enia relacyjne

Wyra¿enia relacyjne s± specjalnym rodzajem wyra¿eñ, zwracaj±cym zawsze
warto¶æ 0 lub 1: zero je¶li relacja jest fa³szywa, za¶ 1 je¿eli jest prawdziwa.
Mog± one wystêpowaæ w dowolnych dozwolonych wyra¿eniach. (POSIX @code{bc}
wymaga, by  wyra¿enia relacyjne by³y u¿ywane wy³±cznie w instrukcjach
@code{if}, @code{while} i @code{for} oraz aby by³o w nich u¿yte tylko jedno
sprawdzenie relacji.)  Operatorami relacji s±:

@table @code
@item wyra¿enie1 < wyra¿enie2
Wynikiem jest jeden je¶li wyra¿enie1 jest mniejsze ni¿ wyra¿enie2.

@item wyra¿enie1 <= wyra¿enie2
Wynikiem jest 1 gdy wyra¿enie jest mniejsze b±d¼ równe wyra¿enie2.

@item wyra¿enie1 > wyra¿enie2
Wynikiem jest 1 je¶li wyra¿enie1 jest wiêksze ni¿ wyra¿enie2.

@item wyra¿enie1 >= wyra¿enie2
Wynikiem jest 1 gdy wyra¿enie1 jest wiêksze b±d¼ równe wyra¿enie2.

@item wyra¿enie1 == wyra¿enie2
Wynikiem jest 1 gdy wyra¿enie1 jest równe wyra¿enie2.

@item wyra¿enie1 != wyra¿enie2
Wynikiem jest 1 gdy wyra¿enie1 nie jest równe wyra¿enie2.
@end table

@node Wyra¿enia logiczne, Priorytet, Wyra¿enia relacyjne, Wyra¿enia
@section Wyra¿enia logiczne

Dozwolone s± tak¿e operacje logiczne. (POSIX @code{bc} NIE posiada
operacji logicznych). Wynikami wszystkich operacji logicznych s± 0 lub 1
(dla fa³szu i prawdy), tak jak dla wyra¿eñ relacyjnych. Operatorami
logicznymi s±:

@table @code
@item !expr
Zaprzeczenie. Wynikiem jest 1 je¶li wyra¿enie ma warto¶æ 0.

@item expr && expr
Koniunkcja. Wynikiem jest 1 je¿eli oba wyra¿enia s± niezerowe.

@item expr || expr
Alternatywa. Wynikiem jest 1 je¶li dowolne z wyra¿eñ jest niezerowe.
@end table

@node Priorytet, Wyra¿enia specjalne, Wyra¿enia logiczne, Wyra¿enia
@section Priorytet

Wyra¿enia posiadaj± nastêpuj±cy priorytet: (od najni¿szego do najwy¿szego)

@example
operator ||, wi±zanie lewe
operator &&, wi±zanie lewe
operator !, niezwi±zany
operatory relacji, wi±zanie lewe
operator przypisania, wi±zanie prawe
operatory + i -, wi±zanie lewe
operatory *, / i %, wi±zanie lewe
operator ^, wi±zanie prawe
jednoargumentowy operator -, niezwi±zany
operatory ++ i --, niezwi±zane
@end example

Kolejno¶æ wykonywania zosta³a dobrana tak, by programy zgodne z POSIX
@code{bc} dzia³a³y poprawnie. Powoduje to, ¿e operatory relacyjne
i logiczne, u¿yte w wyra¿eniach przypisania, bêd± wykazywaæ niecodzienne
zachowywanie.  Rozwa¿ wyra¿enie:

@example
a = 3 < 5
@end example

Wiêkszo¶æ programistów C uwa¿a³aby, ¿e przypisze ono wynik operacji "3 < 5"
(warto¶æ 1) zmiennej "a". Tymczasem w @code{bc} nadaje ono warto¶æ 3
zmiennej "a", a nastêpnie porównuje 3 z 5. U¿ywaj±c operatorów relacji
i operatorów logicznych z operatorami przypisania najlepiej jest pos³u¿yæ siê
nawiasami.

@node Wyra¿enia specjalne, , Priorytet, Wyra¿enia
@section Wyra¿enia specjalne

@code{bc} udostêpnia jeszcze kilka innych wyra¿eñ specjalnych. Zwi±zane
s± one z funkcjami definiowanymi przez u¿ytkownika i funkcjami
standardowymi.  Wszystkie one maj± postaæ
"@var{nazwa}@code{(}@var{parametry}@code{)}".
@xref{Funkcje}, gdzie opisano funkcje definiowane przez u¿ytkownika.
Funkcjami standardowymi s±:

@table @code
@item length ( wyra¿enie )
Wynikiem funkcji @code{length} jest liczba cyfr znacz±cych w wyra¿eniu.

@item read ( )
Funkcja ta, bêd±ca rozszerzeniem, odczytuje liczbê ze standardowego wej¶cia,
niezale¿nie od miejsca u¿ycia funkcji. Strze¿ siê -- mo¿e to spowodowaæ
k³opoty  przy przeplataniu siê danych i programu ze standardowego wej¶cia.
Najlepszym zastosowaniem tej funkcji jest u¿ycie jej w uprzednio napisanym
programie, który wymaga wprowadzania danych przez u¿ytkownika, ale nigdy
nie pozwala na wprowadzanie kodu programu. Wynikiem dzia³ania funkcji
@code{read} jest liczba odczytana ze standardowego wej¶cia z konwersj±
uk³adu liczbowego wed³ug aktualnej warto¶ci zmiennej @var{ibase}.

@item scale ( wyra¿enie )
Wynikiem funkcji @code{scale} jest liczba cyfr po kropce dziesiêtnej w wyra¿eniu
bêd±cym jej parametrem.

@item sqrt ( wyra¿enie )
Wynikiem funkcji @code{sqrt} jest pierwiastek kwadratowy z wyra¿enia. Je¿eli
wyra¿enie ma warto¶æ ujemn±, to generowany jest b³±d wykonania.
@end table

@node Instrukcje, Funkcje, Wyra¿enia, Top
@chapter Instrukcje

@menu
* Pseudo-instrukcje::
@end menu

Instrukcje (jak w wiêkszo¶ci jêzyków algorytmicznych) umo¿liwiaj± sterowanie
kolejno¶ci± wykonywania wyra¿eñ. W @code{bc} instrukcje wykonywane s±
bezzw³ocznie, "tak szybko jak to jest mo¿liwe". Wykonanie odbywa siê gdy
napotkano znak nowej linii i istnieje jedna lub wiêcej pe³na instrukcja.
W zwi±zku z takim natychmiastowym wykonaniem, znaki nowej linii s± bardzo
istotne w @code{bc}. W rzeczywisto¶ci, jako organiczniki instrukcji
u¿ywane s± zarówno znaki nowej linii jak i ¶redniki. Nieprawid³owo
umieszczony znak nowej linii spowoduje b³±d sk³adni. Poniewa¿ znaki nowej
linii rozdzielaj± instrukcje, mo¿liwe jest ich ukrycie (przed interpretacj±)
przy pomocy znaku odwrotnego uko¶nika. Sekwencja "\<nl>", gdzie <nl> jest
znakiem nowej linii postrzegana jest przez @code{bc} jako znak zwyk³ej
spacji zamiast znaku nowej linii.
@c Lista instrukcji jest ci±giem instrukcji rozdzielanych ¶rednikami i
@c znakami nowej linii.
Poni¿ej umieszczono listê instrukcji @code{bc} i ich
znaczenia:  (elementy umieszczone w nawiasach kwadratowych ([]) s±
opcjonalnymi czê¶ciami instrukcji.)

@table @var
@item wyra¿enie
Instrukcja ta wykonuje dwie rzeczy. je¿eli wyra¿enie rozpoczyna siê od
"<zmienna> <przypisanie> ...", to jest traktowane jak instrukcja
przypisania. Je¶li wyra¿enie nie jest instrukcj± przypisania, to wyra¿enie
jest wyliczane i drukowane na standardowym wyj¶ciu. Po wydrukowaniu liczby
drukowany jest znak nowej linii. Na przyk³ad, "a=1" jest instrukcj±
przypisania za¶ "(a=1)" jest wyra¿eniem zawieraj±cym przypisanie. Wszystkie
liczby drukowane s± przy u¿yciu systemu pozycyjnego okre¶lonego zmienn±
@var{obase}. Dopuszczalnymi warto¶ciami @var{obase} s± 2 do BC_BASE_MAX.
(@pxref{Zmienne ¶rodowiska}). Dla podstaw systemu od 2 do 16 u¿ywana jest
zwyczajowa metoda zapisu liczb. Dla podstaw wiêkszych od 16 @code{bc}
pos³uguje siê metod± cyfr wieloznakowych wy¶wietlania liczb, gdzie ka¿da
z kolejnych cyfr wy¶wietlana jest jako liczba dziesiêtna. Cyfry wieloznakowe
oddzielane s± odstêpami. Ka¿da z cyfr zawiera tyle znaków, ile jest
niezbêdnych do przedstawienia dziesiêtnie warto¶ci "@var{obase}-1". Poniewa¿
liczby maj± dowoln± dok³adno¶æ, niektóre z liczb mog± nie daæ wydrukowaæ siê
w pojedynczym wierszu. Takie d³ugie liczby zostan± podzielone miêdzy wiersze
przy zastosowaniu "\" jako ostatniego znaku wiersza. Maksymaln± liczb±
znaków drukowanych w wierszu jest 70. Z powodu interaktywneggo charakteru
@code{bc} drukowanie liczby ma efekt uboczny w postaci przypisania
wydrukowanej warto¶ci do specjalnej zmiennej o nazwie @var{last}. Umo¿liwia
to u¿ytkownikowi odtworzenie ostatnio wydrukowanej warto¶ci bez potrzeby
ponownego wpisywania wyra¿enia, które j± wydrukowa³o. Nadawanie warto¶ci
zmiennej @var{last} jest dozwolone; spowoduje ono zast±pienie ostatnio
wydrukowanej warto¶ci warto¶ci± przypisan±. Nowo przypisana warto¶æ
pozostanie a¿ do wydrukowania kolejnej liczby lub nadania @var{last} innej
warto¶ci. (Niektóre z implementacji mog± dopuszczaæ u¿ycie pojedynczej
kropki (.), nie bêd±cej czê¶ci± liczby, jako skróconej notacji dla
@var{last}.)

@item ³añcuch
Na wyj¶ciu drukowany jest ³añcuch znakowy. £añcuchy rozpoczynaj± siê znakiem
cudzys³owu i zawieraj± wszystkie znaki do nastêpnego znaku cudzys³owu.
Wszystkie znaki, w³±cznie ze znakami nowej linii, traktowane s± dos³ownie.
Po wydrukowaniu ³añcucha nie jest drukowany znak nowej linii.

@item @code{print} @var{lista}
Instrukcja @code{print} (rozszerzenie) umo¿liwia u¿ycie innego sposobu
wydruku wyników. @var{Lista} jest list± ³añcuchów i wyra¿eñ oddzielonych
przecinkami.  Ka¿dy ³añcuch czy wyra¿enie drukowany jest w kolejno¶ci
wystêpowania na li¶cie. Nie jest drukowany koñcz±cy znak nowej linii
(przej¶cie do nastêpnego wiersza). Wyliczana jest warto¶æ wyra¿eñ; jest ona
drukowana i przypisywana zmiennej @code{last}. £añcuchy u¿yte w instrukcji
print s± drukowane na wyj¶ciu i mog± zawieraæ znaki specjalne. Znaki
specjalne rozpoczynaj± siê znakiem odwrotnego uko¶nika ("\"). @code{bc}
rozpoznaje nastêpuj±ce znaki specjalne:  "a" (dzwonek, bell), "b"
(backspace), "f" (wysuw strony, form feed), "n" (nowa linia, newline), "r"
(powrót karetki, carriage return), "q" (cudzys³ów, double quote), "t"
(tabulacja, tab) oraz "\" (odwrotny uko¶nik, backslash).  Inne znaki
wystêpuj±ce po odwrotnym uko¶niku bêd± ignorowane.

@item @{ lista_instrukcji @}
Jest to polecenie z³o¿one: nawiasy klamrowe s³u¿± jako instrukcja
grupowania.  Pozwala na grupowanie wielu instrukcji do wykonania.

@item @code{if} ( wyra¿enie ) instrukcja1 [@code{else} instrukcja2]

Instrukcja @code{if} oblicza wyra¿enie i wykonuje @var{instrukcjê1} b±d¼
@var{instrukcjê2} w zale¿no¶ci od warto¶ci wyra¿enia. Je¿eli wyra¿enie jest
niezerowe, wykonywana jest @var{instrukcja1}. Je¶li wystêpuje
@var{instrukcja2} a warto¶ci± wyra¿enia jest 0, to wykonywana jest
@var{instrukcja2}. (Klauzula @code{else} instrukcji @code{if} jest
rozszerzeniem).

@item @code{while} ( wyra¿enie ) instrukcja
Instrukcja @code{while} powtarza wykonywanie danej instrukcji póki wyra¿enie
jest niezerowe. Oblicza ona warto¶æ wyra¿enia przed ka¿dym wykonaniem
instrukcji.  Przerwanie pêtli powodowane jest zerow± warto¶ci± wyra¿enia lub
wykonaniem instrukcji @code{break} (przerwania).

@item @code{for} ( [wyr1] ; [wyr2] ; [wyr3] ) instrukcja
Instrukcja @code{for} kontroluje powtarzane wykonanie danej instrukcji.
Przed pêtl± obliczane jest @var{wyra¿enie1}. @var{Wyra¿enie2} jest obliczane
przed ka¿dym wykonaniem instrukcji. Je¶li jest niezerowe, to wykonywana jest
instrukcja.  Je¶li ma ono warto¶æ zero, to pêtla jest przerywana. Po ka¿dym
wykonaniu danej instrukcji wyliczana jest warto¶æ @var{wyra¿enia3} przed
ponownym wyliczeniem @var{wyra¿enia2}. Je¿eli pominiêto @var{wyra¿enie1} lub
@var{wyra¿enie3}, to nic nie jest obliczane w chwili, gdy powinna byæ
okre¶lana ich warto¶æ.  Je¿eli pominiêto @var{wyra¿enie2}, to jest ono
zastêpowane warto¶ci± 1. (Wyra¿enie opcjonalne stanowi± rozszerzenie.
@code{bc} w POSIX-ie wymaga wszystkich trzech wyra¿eñ.) Poni¿szy kod jest
równowa¿ny instrukcji @code{for}:

@example
expression1;
while (expression2) @{
   statement;
   expression3;
@}
@end example

@item @code{break}
Instrukcja ta powoduje wymuszone zakoñczenie ostatniej obejmuj±cej j±
instrukcji @code{while} lub @code{for}.

@item @code{continue}
Instrukcja @code{continue} (rozszerzenie) powoduje rozpoczêcie kolejnej
iteracji przez ostatni± obejmuj±c± j± instukcjê @code{for}.

@item @code{halt}
Instrukcja @code{halt} (rozszerzenie) jest instrukcj± nakazuj±c±
preprocesorowi @code{bc} zakoñczenie pracy (ale tylko wtedy gdy
instrukcja ta jest wykonywana).  Na przyk³ad, "if (0 == 1) halt" nie
spowoduje przerwania pracy @code{bc}, gdy¿ instrukcja @code{halt} nie
bêdzie wykonana.

@item @code{return}
Zwraca warto¶æ zero jako wynik funkcji.  (@xref{Funkcje}.)

@item @code{return} ( wyra¿enie )
Zwraca warto¶æ wyra¿enia jako wynik funkcji.  (@xref{Funkcje}.)
Nawiasy nie s± wymagane, co jest rozszerzeniem GNU.
@end table

@node Pseudo-instrukcje, , Instrukcje, Instrukcje
@section Pseudo-instrukcje

Te instrukcje nie s± instrukcjami w tradycyjnym sensie tego terminu. Nie s±
one instrukcjami wykonywanymi. Ich funkcja jest wykonywana podczas
"kompilacji".

@table @code
@item limits
Wypisuje lokalne ograniczenia narzucone przez lokalna wersjê @code{bc}.
Jest to rozszerzenie.

@item quit
Po odczycie instrukcji @code{quit} procesor @code{bc} koñczy pracê,
niezale¿nie od tego, gdzie wyst±pi³a ta instrukcja. Na przyk³ad,
"if (0 == 1) quit" spowoduje zakoñczenie pracy @code{bc}.

@item warranty
Wypisuje d³u¿sz± notkê na temat gwarancji. Jest to rozszerzenie.
@end table

@node Funkcje, Przyk³ady, Instrukcje, Top
@chapter Funkcje

@menu
* Funkcje biblioteki matematycznej::
@end menu

Funkcje dostarczaj± sposobu definiowania obliczeñ, które mog± byæ wykonane
pó¼niej. Funkcje w @code{bc} zawsze obliczaj± warto¶æ i zwracaj± j± do
miejsca wywo³ania. Definicje funkcji s± "dynamiczne" w tym sensie, ¿e funkcja
pozostaje niezdefiniowana dopóki na wej¶ciu nie zostanie odczytana jej
definicja. Definicja ta jest nastêpnie u¿ywana dopóki nie zostanie napotkana
inna definicja funkcji o tej samej nazwie. Wówczas nowa definicja zastêpuje
starsz±. Funkcja definiowana jest nastêpuj±co:

@example
@code{define} @var{nazwa} @code{(} @var{parametry} @code{)} @code{@{} @var{nowa_linia}
    @var{lista_auto   lista_instrukcji} @code{@}}
@end example

Wywo³anie funkcji jest po prostu wyra¿eniem postaci
"@code{nazwa} @code{(}@var{parametry}@code{)}".

Parametry s± liczbami lub tablicami (rozszerzenie). W definicji funkcji
definiuje siê równocze¶nie jest zero lub wiêcej jej parametrów przez podanie
ich nazw rozdzielonych przecinkami. Liczby s± jedynymi parametrami wywo³ywanymi
przez warto¶æ. Tylko tablice s± wo³ane przez wskazanie zmiennej.
Tablice podawane s± w definicji parametrów przy pomocy notacji
"@var{nazwa}@code{[ ]}". W wywo³aniu funkcji parametry rzeczywiste dla
parametrów numerycznych s± pe³nymi wyra¿eniami. Do przekazywania tablic
u¿ywana jest ta sama notacja, co przy definiowaniu parametrów typu
tablicowego. Dana tablica przesy³ana jest do funkcji przez nazwê
(wskazanie). Poniewa¿ definicje funkcji s± dynamiczne, w trakcie wywo³ywania
funkcji sprawdzana jest liczba i typy jej parametrów.  Niezgodno¶c liczby
parametrów lub ich typów powoduje b³±d wykonania. B³±d wykonania pojawi siê
tak¿e przy próbie wywo³ania niezdefiniowanej funkcji.

@var{lista_auto} jest opcjonaln± list± zmiennych, do u¿ytku "lokalnego".
A oto sk³adnia tej listy (je¶li wystêpuje): "@code{auto} @var{nazwa}, ... ;".
¦rednik jest opcjonalny. Ka¿da z @var{nazw} jest nazw± auto-zmiennej.
Tablice mog± byæ podane przy u¿yciu takiej samej sk³adni jak w parametrach.
Na pocz±tku funkcji warto¶ci tych zmiennych odk³adane s± na stosie.
Nastêpnie zmienne s± inicjowane zerami i u¿ywane w czasie wykonywania
funkcji. Przy zakoñczeniu funkcji zmienne s± zdejmowane ze stosu,
tak ¿e przywracana jest ich pierwotna warto¶æ (z momentu wywo³ania
funkcji). Parametry te s± faktycznie zmiennymi auto inicjowanymi warto¶ciami
dostarczonymi w wywo³aniu funkcji. Zmienne typu auto ró¿ni± siê od
tradycyjnych zmiennych lokalnych, gdy¿ je¶li funkcja A wo³a funkcjê B, to
B mo¿e pos³ugiwaæ siê zmiennymi auto funkcji A po prostu u¿ywaj±c tych
samych nazw, chyba ¿e funkcja B traktuje je jako zmienne auto. Poniewa¿
zmienne auto i parametry sk³adowane s± na stosie, to @code{bc} obs³uguje
funkcje rekurencyjne.

Cia³o funkcji jest list± instrukcji @code{bc}. I znów, jak w czê¶ci
zasadniczej, instrukcje oddzielane s± ¶rednikami lub znakami nowej linii.
Instrukcje return (powrót) powoduj± zakoñczenie funkcji i zwrócenie
warto¶ci. Istniej± dwa warianty instrukcji return. Pierwsza postaæ,
"@code{return}", zwraca warto¶æ 0 do wywo³uj±cego wyra¿enia. Druga
postaæ, "@code{return} ( @var{wyra¿enie} )", oblicza warto¶æ wyra¿enia
i zwraca j± do wyra¿enia wo³aj±cego. Ka¿da funkcja domy¶lnie koñczy siê
niejawn± instrukcj± "@code{return} (0)". Pozwala to na funkcji na
zakoñczenie dzia³ania i zwrócenie zera bez jawnej instrukcji powrotu.

Funkcje inaczej korzystaj± ze zmiennej @var{ibase}. Wszystkie sta³e
w obrêbie cia³a funkcji bêd± konwertowane przy zastosowaniu
warto¶ci @var{ibase} w momencie wywo³ania funkcji. Zmiany @var{ibase} w
czasie wykonywania funkcji s± ignorowane, z wyj±tkiem funkcji standardowej
@code{read}, która zawsze do konwersji liczb wykorzystuje bie¿±c± warto¶æ
@var{ibase}.

Rozszerzeniem GNU @code{bc} jest nieco lu¼niejszy format dla definicji.
Standard wymaga, by nawias otwieraj±cy znajdowa³ siê w tym samym wierszu
co s³owo kluczowe @code{define}, a wszystkie pozosta³e czê¶ci w kolejnych
wierszach. Opisywana tu wersja @code{bc} zezwala na dowoln± ilo¶æ znaków
nowej linii przed i po nawiasie otwieraj±cym funkcji.  Na przyk³ad,
dozwolone s± poni¿sze definicje.

@example
   define d (n) @{ return (2*n); @}
   define d (n)
       @{ return (2*n); @}
@end example


@node Funkcje biblioteki matematycznej, , Funkcje, Funkcje
@section Funkcje biblioteki matematycznej

Je¿eli @code{bc} wywo³ywane jest z opcj± @code{-l}, to wstêpnie
wczytywana jest biblioteka matematyczna (math library), a domy¶lna liczba
cyfr dziesiêtnych (@var{scale}) ustawiana jest na 20. Funkcje matematyczne
obliczaj± swe wyniki z dok³adno¶ci± okre¶lon± w momencie ich wywo³ania.
Bibilioteka matematyczna definiuje nastêpuj±ce funkcje:

@table @code
@item s (@var{x})
Sinus @var{x}, @var{x} podawany jest w radianach.

@item c (@var{x})
Cosinus @var{x}, @var{x} w radianach.

@item a (@var{x})
Arcus tangens @var{x}; arcus tangens zwraca radiany.

@item l (@var{x})
Logarytm naturalny z @var{x}.

@item @var{e} (@var{x})
Funkcja wyk³adnicza - @var{e} do potêgi @var{x}.

@item @var{j} (@var{n,x})
Funkcja Bessela rzêdu @var{n} (ca³kowitego) z argumentem @var{x}.
@end table

@node Przyk³ady, Opcje Readline i Libedit, Funkcje, Top
@chapter Przyk³ady

W pow³oce @code{/bin/sh}, poni¿sze polecenie przypisuje warto¶æ liczby "Pi"
zmiennej ¶rodowiska @var{pi}.
@example

pi=$(echo "scale=10; 4*a(1)" | bc -l)

@end example

Poni¿ej podano definicjê funkcji wyk³adniczej u¿ywanej w bibliotece
matematycznej. Funkcja ta napisana jest w  @code{bc} standardu POSIX.

@example

scale = 20

/* wykorzystuje fakt, ¿e e^x = (e^(x/2))^2
   Gdy  x jest dostatecznie ma³e, u¿ywamy szeregu:
     e^x = 1 + x + x^2/2! + x^3/3! + ...
*/

define e(x) @{
  auto  a, d, e, f, i, m, v, z

  /* sprawdzenie znaku x */
  if (x<0) @{
    m = 1
    x = -x
  @}

  /* przewidywane x */
  z = scale;
  scale = 4 + z + .44*x;
  while (x > 1) @{
    f += 1;
    x /= 2;
  @}

  /* inicjowanie zmiennych */
  v = 1+x
  a = x
  d = 1

  for (i=2; 1; i++) @{
    e = (a *= x) / (d *= i)
    if (e == 0) @{
      if (f>0) while (f--)  v = v*v;
      scale = z
      if (m) return (1/v);
      return (v/1);
    @}
    v += e
  @}
@}

@end example

Poni¿szy kod pos³uguje siê rozszerzonymi cechami @code{bc} do uzyskania
prostego programu licz±cego salda ksi±¿eczki czekowej. Najlepiej by³oby
zachowaæ go w pliku, tak by móg³ byæ wykorzystany wielokrotnie bez potrzeby
ka¿dorazowego przepisywania.

@example

scale=2
print "\enProgram ksi±¿eczki czekowej!\en"
print "  Pamiêtaj, wp³aty s± transakcjami ujemnymi.\en"
print "  Koniec - transakcja zerowa.\en\en"

print "Saldo pocz±tkowe? "; bal = read()
bal /= 1
print "\n"
while (1) @{
  "bie¿±ce saldo = "; bal
  "transakcja? "; trans = read()
  if (trans == 0) break;
  bal -= trans
  bal /= 1
@}
quit

@end example


Poni¿ej zamieszczono definicjê rekurencyjnej funkcji silni.

@example

define f (x) @{
  if (x <= 1) return (1);
  return (f(x-1) * x);
@}

@end example

@node Opcje Readline i Libedit, GNU bc a inne implementacje, Przyk³ady, Top
@chapter Opcje Readline i Libedit

GNU @code{bc} mo¿e zostaæ skompilowany (poprzez opcjê konfiguracji) tak,
by pos³ugiwa³ siê bibliotek± GNU edytora wej¶cia o nazwie @code{readline}
lub te¿ bibliotek± BSD @code{libedit}.  Umo¿liwia to u¿ytkownikowi edycjê
wierszy przed wys³aniem ich do @code{bc}. Pozwala te¿ na wykorzystanie
historii poprzednio wprowadzonych wierszy. Przy wybraniu tej opcji
@code{bc} posiada dodatkow± zmienn± specjaln±. Ta specjalna zmienna,
@var{history}, przechowuje liczbê zachowywanych wierszy historii.
Warto¶æ -1 oznacza, ¿e przechowywana jest nieograniczona liczba wierszy
historii.  Ustawienie warto¶ci @var{history} na liczbê dodatni± ogranicza
liczbê przechowywanych wierszy historii do podanej liczby. Warto¶æ zero
wy³±cza funkcjê historii wprowadzonych wierszy.  Warto¶ci± domy¶ln± jest
100.  Wiêcej informacji mo¿na znale¼æ w podrêcznikach u¿ytkownika dla
bibliotek GNU @code{readline} i @code{history} oraz BSD
@code{libedit}.  Nie mo¿na równocze¶nie w³±czyæ zarówno @code{readline}
jak i @code{libedit}.

@node GNU bc a inne implementacje, Ograniczenia, Opcje Readline i Libedit, Top
@chapter GNU @code{bc} a inne implementacje

Niniejsza wersja @code{bc} zosta³a zbudowana w oparciu o projekt POSIX
P1003.2/D11 i zawiera kilka ró¿nic i rozszerzeñ w stosunku do tego dokumentu
i tradycyjnych realizacji.  Nie jest wykonana w tradycyjny sposób,
wykorzystuj±cy polecenie @code{dc}.  Wersja ta jest pojedynczym procesem,
analizuj±cym i uruchamiaj±cym kod binarny bêd±cy t³umaczeniem programu.
Istnieje "nieudokumentowana" opcja (-c) powoduj±ca, ¿e program wy¶wietla kod
binarny na standardowym wyj¶ciu zamiast wykonywania go. U¿ywana by³a ona
g³ównie do debuggowania analizatora sk³adni i przy przygotowaniu
biblioteki matematycznej.

G³ównym ¼ród³em ró¿nic s± rozszerzenia, w których jaka¶ cecha, mo¿liwo¶æ
programu jest rozbudowana w celu dodania funkcjonalno¶ci, oraz dodatki, gdzie
dodano nowe mo¿liwo¶ci.
Poni¿ej podano listê ró¿nic i rozszerzeñ.

@table @var

@item Zmienna ¶rodowiska LANG
Niniejsza wersja nie spe³nia standardu POSIX przetwarzania zmiennej
¶rodowiska @env{LANG} i wszystkich zmiennych ¶rodowiska rozpoczynaj±cych
siê na @env{LC_}.

@item nazwy
Tradycyjny i POSIX-owy @code{bc} posiadaj± jednoliterowe nazwy funkcji,
zmiennych i tablic. Zosta³y one rozszerzone do nazw wieloznakowych,
rozpoczynaj±cych siê liter± i mog±cych zawieraæ litery, cyfry i znaki
podkre¶lenia.

@item ³añcuchy
£añcuchy nie mog± zawieraæ znaków NUL. POSIX stwierdza, ¿e wszystkie znaki
musz± byæ zawarte w ³añcuchach.

@item last
POSIX @code{bc} nie posiada zmiennej @var{last}. Niektóre implementacje
@code{bc} u¿ywaj± kropki (.) w podobny sposób.

@item porównania
POSIX @code{bc} dopuszcza porównania wy³±cznie w instrukcjach @code{if},
@code{while} oraz w drugim wyra¿eniu instrukcji @code{for}.  Dodatkowo,
w ka¿dej z tych instrukcji dopuszczalna jest tylko jedna operacja
porównania (relacji).

@item instrukcja if, klauzula else
POSIX @code{bc} nie posiada klauzuli @code{else}.

@item instrukcja for
POSIX @code{bc} wymaga, by w instrukcji @code{for} wystêpowa³y wszystkie
wyra¿enia.

@item &&, ||, !
POSIX @code{bc}  nie posiada operatorów logicznych.

@item funkcja read
POSIX @code{bc} nie posiada funkcji @code{read}.

@item instrukcja print
POSIX @code{bc} nie posiada instrukcji @code{print}.

@item instrukcja continue
POSIX @code{bc} nie posiada instrukcji @code{continue}.

@item instrukcja return
POSIX @code{bc} wymaga nawiasów wokó³ zwracanego wyra¿enia.

@item parametry tablicowe
POSIX @code{bc} nie obs³uguje (obecnie) w pe³ni parametrów tablicowych.
Gramatyka POSIX zezwala na u¿ycie tablic w definicjach funkcji, ale nie
zapewnia metody przekazania tablicy jako bie¿±cego parametru. (Jest to
najprawdopodobniej przeoczenie w zdefiniowanej gramatyce.) Tradycyjne
implementacje @code{bc} posiadaj± jedynie wywo³anie parametrów tablicowych
przez warto¶æ.

@item format funkcji
POSIX @code{bc} wymaga, by nawias otwieraj±cy by³ w tym samym wierszu, co
s³owo kluczowe @code{define}, za¶ instrukcja @code{auto} w nastêpnym wierszu.

@item =+, =-, =*, =/, =%, =^
POSIX @code{bc} nie wymaga, by by³y zdefiniowane powy¿sze operatory
przypisania "starego typu". Niniejsza wersja zezwala na takie przypisania
w "starym stylu". Nale¿y skorzystaæ z instrukcji @code{limits}, by
stwierdziæ, czy zainstalowana wersja je rozpoznaje. Je¿eli obs³uguje ona
przypisania w "starym stylu", to instrukcja "a =- 1" pomniejszy @code{a}
o jeden zamiast przypisaæ @code{a} warto¶æ -1.

@item spacje w liczbach
Inne implementacje @code{bc} dopuszczaj± wystêpowanie spacji w liczbach.
Na przyk³ad, "x=1 3" przypisze warto¶æ 13 zmiennej x. Ta sama instrukcja
spowoduje b³±d sk³adni w opisywanej tu wersji @code{bc}.

@item b³êdy i wykonanie
Opisywana implementacja ró¿ni siê od innych sposobem, w jaki wykonywany jest
kod w przypadku znalezienia w programie b³êdów sk³adniowych i innych.
W przypadku napotkania b³êdu w definicji funkcji, obs³uga b³êdów próbuje
odnale¿æ pocz±tek instrukcji i kontynuowaæ analizê sk³adniow±
funkcji.
Po znalezieniu b³êdu w funkcji, nie jest ona mo¿liwa do wywo³ania i staje
siê niezdefiniowana. B³êdy sk³adniowe w interaktywnym wykonywaniu kodu
uniewa¿niaj± bie¿±cy blok wykonania. Blok wykonania jest zakoñczony
koñcem linii pojawiaj±cym siê po pe³nej sekwencji instrukcji.
Na przyk³ad,

@example
a = 1
b = 2
@end example

posiada dwa bloki wykonania a

@example
@{ a = 1
  b = 2 @}
@end example

ma jeden blok wykonania.
Ka¿dy z b³êdów wykonania przerywa wykonywanie bie¿±cego bloku wykonania.
Ostrze¿enie w trakcie wykonywania nie przerywa bie¿±cego bloku.

@item przerwania
Podczas sesji interaktywnej sygna³ SIGINT (zwykle generowany przez znak
control-C z terminala) spowoduje przerwanie bie¿±cego bloku wykonywania.
Wy¶wietli on b³±d wykonania ("runtime"), wskazuj±cy która funkcja zosta³a
przerwana. Po wyczyszczeniu wszystkich struktur (runtime structures)
wykonania, zostanie wy¶wietlony komunikat informuj±cy u¿ytkownika, ¿e
@code{bc} jest gotów do przyjmowania kolejnych danych. Wszystkie uprzednio
zdefiniowane funkcje pozostaj± zdefiniowane, za¶ warto¶ci wszystkich
zmiennych innych ni¿ zmienne typu auto s± warto¶ciami sprzed przerwania.
Podczas procesu oczyszczania struktur danych usuwane s± wszystkie zmienne
typu auto oraz parametry funkcji.
W czasie sesji nieinteraktywnej sygna³ SIGINT przerywa wykonanie ca³ego
@code{bc}.
@end table

@node Ograniczenia, Zmienne ¶rodowiska, GNU bc a inne implementacje, Top
@chapter Ograniczenia

Poni¿ej podano obecne ograniczenia opisywanego procesora @code{bc}.
Niektóre z nich mog± byæ zmienione podczas instalacji. Faktyczne
ograniczenia mo¿na sprawdziæ za pomoc± instrukcji @code{limits}
(ograniczenia).

@table @code

@item BC_BASE_MAX
Maksymalna podstawa pozycyjnego uk³adu, w którym wyprowadzane s± wyniki
obecnie ustawiona jest na 999. Maksymaln± podstaw± uk³adu wej¶ciowego jest 16.

@item BC_DIM_MAX
Obecnie ustawione jest arbitralne ograniczenie do 65535 (w wersji
rozpowszechnianej). Twoja instalacja mo¿e byæ inna.

@item BC_SCALE_MAX
Liczba cyfr po kropce dziesiêtnej ograniczona jest do INT_MAX cyfr. Tak¿e
liczba cyfr przed kropk± dziesiêtn± ograniczona jest do INT_MAX cyfr.

@item BC_STRING_MAX
Maksymalnie w ³añcuchu mo¿e wyst±piæ INT_MAX znaków.

@item exponent
Warto¶æ wyk³adnika w operacji potêgowania (^) ograniczona jest do LONG_MAX.

@item multiply
Procedura mno¿enia mo¿e dawaæ nieprawid³owe wyniki je¿eli liczba posiada
wiêcej ni¿ LONG_MAX / 90 cyfr ogó³em. Dla 32 bitowych d³ugich liczb
ca³kowitych (longint) jest to 23,860,929 cyfr.

@item nazwy zmiennych
Obecnie nie mo¿e byæ wiêcej ni¿ 32767 unikalnych nazw w ka¿dym z rodzajów:
zmiennych prostych, tablic i funkcji.
@end table

@node Zmienne ¶rodowiska, Zg³aszanie b³êdów, Ograniczenia, Top
@chapter Zmienne ¶rodowiska

@code{bc} przetwarza nastêpuj±ce zmienne ¶rodowiska:

@table @code

@item POSIXLY_CORRECT
To samo, co opcja @samp{-s}. Tryb zgodno¶ci z POSIX.
(@pxref{Opcje wiersza poleceñ}).

@item BC_ENV_ARGS
Inny sposób przekazywania argumentów do @code{bc}.  Format jest taki sam,
jak argumentów wiersza poleceñ.  Argumenty te przetwarzane s± na pocz±tku,
wiêc pliki podane w argumentach ¶rodowiska przetwarzane s± przed plikami
podanymi jako argumenty wiersza poleceñ.  Umo¿liwia to u¿ytkownikowi
ustawienie "standardowych" opcji i plików, jakie bêd± przetwarzane przy
ka¿dym wywo³aniu @code{bc}.  Pliki podane w zmiennych ¶rodowiska zawieraj±
zwykle definicje funkcji, które u¿ytkownik chce mieæ zdefiniowane przy
ka¿dym uruchomieniu @code{bc}.

@item BC_LINE_LENGTH
Powinna to byæ liczba ca³kowita (integer) podaj±ca ilo¶æ znaków w wierszu
wynikowym.  Obejmuje ona znaki odwrotnego uko¶nika i nowej linii dla d³ugich
liczb.
@end table

@node Zg³aszanie b³êdów, , Zmienne ¶rodowiska, Top
@chapter Zg³aszanie b³êdów

Zg³oszenia b³êdów proszê nadsy³aæ na adres @email{bug-bc@@gnu.org}.
Upewnij siê, ¿e pole tematu wiadomo¶ci zawiera gdzie¶ s³owo ``bc''.

@contents
@bye
