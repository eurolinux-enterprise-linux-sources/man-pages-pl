# Polish translation of select.2 man page
# This file is distributed under the same license as original manpage
# Copyright of the original manpage:
# Copyright © 1992 Drew Eckhardt, 1995 Michael Shields ("manpages-1")
# Copyright © of Polish translation:
# Przemek Borys (PTM) <pborys@dione.ids.pl>, 1999.
# Robert Luberda <robert@debian.org>, 2006, 2012.
msgid ""
msgstr ""
"Project-Id-Version: manpages-pl\n"
"POT-Creation-Date: 2012-06-07 21:12+0300\n"
"PO-Revision-Date: 2012-05-16 22:38+0200\n"
"Last-Translator: Robert Luberda <robert@debian.org>\n"
"Language-Team: Polish <manpages-pl-list@lists.sourceforge.net>\n"
"Language: pl\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 1.2\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
"|| n%100>=20) ? 1 : 2);\n"

#. type: TH
#, no-wrap
msgid "SELECT"
msgstr "SELECT"

#. type: TH
#, no-wrap
msgid "2010-08-31"
msgstr "2010-08-31"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Podręcznik programisty Linuksa"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "NAZWA"

#. type: Plain text
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchroniczne "
"zwielokrotnianie wejście/wyjście"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "SKŁADNIA"

#. type: Plain text
#, no-wrap
msgid "/* According to POSIX.1-2001 */\n"
msgstr "/* Zgodnie z POSIX.1-2001 */\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "/* According to earlier standards */\n"
msgstr "/* Zgodnie z wcześniejszymi standardami */\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr "B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Wymagane ustawienia makr biblioteki glibc (patrz B<feature_test_macros>(7)):"

#. type: Plain text
msgid ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"
msgstr ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "OPIS"

#. type: Plain text
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become \"ready"
"\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform the "
"corresponding I/O operation (e.g., B<read>(2))  without blocking."
msgstr ""
"B<select>() i B<pselect>() umożliwiają programowi monitorowanie wielu "
"deskryptorów plików i oczekiwanie aż jeden lub więcej deskryptorów będzie "
"\"gotowy\" na wykonanie pewnej klasy operacji wejścia/wyjścia (np. możliwy "
"odczyt). Deskryptor pliku jest uważany za gotowy, jeżeli możliwe jest "
"wykonanie odpowiadającej operacji (np. B<read>(2)) bez blokowania."

#. type: Plain text
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, with three "
"differences:"
msgstr ""
"Funkcjonalność funkcji B<select>() i B<pselect>() jest identyczna, jeśli "
"pominąć trzy różnice:"

#. type: TP
#, no-wrap
msgid "(i)"
msgstr "(i)"

#. type: Plain text
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""
"Funkcja B<select>() używa dla parametru I<timeout> typu I<struct timeval> (z "
"sekundami i mikrosekundami), podczas gdy B<pselect>() używa typu I<struct "
"timespec> (z sekundami i nanosekundami)."

#. type: TP
#, no-wrap
msgid "(ii)"
msgstr "(ii)"

#. type: Plain text
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""
"Funkcja B<select>() może aktualizować parametr I<timeout>, aby wskazać, jak "
"dużo czasu minęło. Funkcja B<pselect>() nie zmienia tego parametru."

#. type: TP
#, no-wrap
msgid "(iii)"
msgstr "(iii)"

#. type: Plain text
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""
"Funkcja B<select>() nie przyjmuje parametru I<sigmask> i zachowuje się, jak "
"B<pselect>() wywołane z NULL-em przekazanym w I<sigmask>."

#. type: Plain text
msgid ""
"Three independent sets of file descriptors are watched.  Those listed in "
"I<readfds> will be watched to see if characters become available for reading "
"(more precisely, to see if a read will not block; in particular, a file "
"descriptor is also ready on end-of-file), those in I<writefds> will be "
"watched to see if a write will not block, and those in I<exceptfds> will be "
"watched for exceptions.  On exit, the sets are modified in place to indicate "
"which file descriptors actually changed status.  Each of the three file "
"descriptor sets may be specified as NULL if no file descriptors are to be "
"watched for the corresponding class of events."
msgstr ""
"Podglądane są trzy niezależne zestawy deskryptorów. Te, które są wymienione "
"w I<readfds>, będą obserwowane w celu dowiedzenia się, czy nie ma tam "
"jakichś znaków dostępnych do czytania (dokładniej, aby dowiedzieć się, czy "
"read nie spowoduje zablokowania, deskryptor pliku jest również przygotowany "
"na koniec pliku). Deskryptory wymienione w I<writefds> będą obserwowane w "
"celu dowiedzenia się, czy zapis nie spowoduje blokady, a deskryptory "
"wymienione w I<exceptfds> będą obserwowane w celu dowiedzenia się, czy nie "
"ma na nich wyjątku. Przy wyjściu, zbiory te są modyfikowane, wskazując, "
"które z deskryptorów zmieniły status. Każdy z tych trzech zbiorów "
"deskryptorów plików może być przekazany jako NULL, jeżeli dla żadnego "
"deskryptora pliku na ma potrzeby obserwowania odpowiedniej klasy zdarzeń."

#. type: Plain text
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given file "
"descriptor from a set.  B<FD_ISSET>()  tests to see if a file descriptor is "
"part of the set; this is useful after B<select>()  returns."
msgstr ""
"Do obsługi tych zbiorów udostępnione są cztery makra: B<FD_ZERO>() czyści "
"zbiór; B<FD_SET>() i B<FD_CLR>() dodają lub usuwają ze zbioru podany "
"deskryptor; B<FD_ISSET>() sprawdza, czy deskryptor jest częścią zbioru. Jest "
"to przydatne po zakończeniu B<select>()."

#. type: Plain text
msgid ""
"I<nfds> is the highest-numbered file descriptor in any of the three sets, "
"plus 1."
msgstr ""
"I<nfds> jest najwyższym numerem deskryptora z wszystkich trzech zbiorów plus "
"1."

#. type: Plain text
msgid ""
"I<timeout> is an upper bound on the amount of time elapsed before B<select>"
"()  returns.  If both fields of the I<timeval> structure are zero, then "
"B<select>()  returns immediately.  (This is useful for polling.)  If "
"I<timeout> is NULL (no timeout), B<select>()  can block indefinitely."
msgstr ""
"I<timeout> jest górną granicą czasu, który upłynie przed zakończeniem "
"działania funkcji B<select>(). Jeśli oba pola struktury I<timeval> mają "
"wartość zero, B<select>() zakończy pracę natychmiast. (Jest to przydatne w "
"uwspólnianiu). Jeśli I<timeout> jest równe NULL (brak czasu "
"przeterminowania), B<select>() może blokować w nieskończoność."

#. type: Plain text
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""
"I<sigmask> jest wskaźnikiem do maski sygnałów (zobacz B<sigprocmask>(2)). "
"Jeśli nie jest równe NULL, to B<pselect>() najpierw zastępuje bieżącą maskę "
"sygnałów maską wskazywaną przez I<sigmask>, a następnie wywołuje funkcję "
"\"select\", a po jej zakończeniu odtwarza oryginalną maskę sygnałów."

#. type: Plain text
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""
"Poza różnicą w precyzji argumentu I<timeout>, następujące wywołanie "
"B<pselect>():"

#. type: Plain text
#, no-wrap
msgid ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"
msgstr ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"

#. type: Plain text
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "jest odpowiednikiem I<niepodzielnego> wykonania następujących funkcji:"

#. type: Plain text
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""
"Idea B<pselect>() polega na tym, że gdy chce się oczekiwać na zdarzenie "
"będące sygnałem lub czymś na deskryptorze pliku, potrzebny jest atomowy test "
"zapobiegający sytuacjom wyścigu. (Przypuśćmy, że procedura obsługi sygnału "
"ustawia globalny znacznik i kończy działanie. Wówczas, test tego znacznika "
"globalnego, po którym następuje wywołanie B<select>() może wisieć w "
"nieskończoność, gdyby sygnał przybył natychmiast po teście, ale przed "
"wywołaniem. Inaczej mówiąc, B<pselect> zezwala na, najpierw, zablokowanie "
"sygnałów, następnie obsłużenie dostarczonych sygnałów, aby wreszcie wywołać "
"B<pselect>() z pożądanym I<sigmask>, unikając wyścigu)."

#. type: SS
#, no-wrap
msgid "The timeout"
msgstr "Przeterminowanie"

#. type: Plain text
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr ""
"Struktury czasu, których to dotyczy, są zdefiniowane w I<E<lt>sys/time."
"hE<gt>> i wyglądają następująco"

#. type: Plain text
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    long    tv_sec;         /* sekundy */\n"
"    long    tv_usec;        /* mikrosekundy */\n"
"};\n"

#. type: Plain text
msgid "and"
msgstr "i"

#. type: Plain text
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* sekundy */\n"
"    long    tv_nsec;        /* nanosekundy */\n"
"};\n"

#. type: Plain text
msgid "(However, see below on the POSIX.1-2001 versions.)"
msgstr "(Jednakże zobacz poniżej uwagi dotyczące POSIX.1-2001)."

#. type: Plain text
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""
"Niektóre programy wywołują B<select>() z wszystkimi trzema zbiorami pustymi, "
"z I<nfds> równym zeru i niezerowym I<timeout>. Jest to całkiem przenośny "
"sposób pauzowania z dokładnością subsekundową."

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1-2001 permits "
"either behavior.)  This causes problems both when Linux code which reads "
"I<timeout> is ported to other operating systems, and when code is ported to "
"Linux that reuses a I<struct timeval> for multiple B<select>()s in a loop "
"without reinitializing it.  Consider I<timeout> to be undefined after "
"B<select>()  returns."
msgstr ""
"Pod Linuksem funkcja B<select>() modyfikuje I<timeout>, aby odzwierciedlić "
"ilość nieprzespanego czasu; większość innych implementacji tego nie robi "
"(POSIX.1-2001 dopuszcza oba te zachowania). Powoduje to problemy, zarówno "
"gdy kod linuksowy odczytujący I<timeout> zostanie przeniesiony na inne "
"systemy operacyjne, jak i gdy kod przeniesiony pod Linuksa z innych systemów "
"używa ponownie struktury I<timeval> dla wielu wywołań B<select>() w pętli, "
"bez powtórnej inicjacji. Prosimy rozważyć traktowanie wartości I<timeout> "
"jako niezdefiniowanej po zakończeniu funkcji B<select>()."

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "WARTOŚĆ ZWRACANA"

#. type: Plain text
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set appropriately; the "
"sets and I<timeout> become undefined, so do not rely on their contents after "
"an error."
msgstr ""
"Po pomyślnym zakończeniu, B<select>() i B<pselect>() zwracają liczbę "
"deskryptorów w zbiorach deskryptorów (to jest całkowitę liczbę bitów "
"ustawioną w I<readfds>, I<writefds>, I<exceptfds>). Może ona być zerowa, "
"jeśli nastąpi przeterminowanie, nim coś ciekawego się zdarzy. Po błędzie, "
"zwracane jest -1 i odpowiednio ustawiane I<errno>; zbiory deskryptorów i "
"I<timeout> stają się niezdefiniowane, więc nie należy polegać na ich "
"zawartości."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "BŁĘDY"

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)"
msgstr ""
"W jednym ze zbiorów przekazano niepoprawny deskryptor pliku (Być może "
"deskryptor ten został już zamknięty lub wystąpił na nim inny błąd)."

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
msgid "A signal was caught; see B<signal>(7)."
msgstr "Przechwycono sygnał, patrz B<signal>(7)."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"I<nfds> is negative or the value contained within I<timeout> is invalid."
msgstr "I<nfds> jest ujemne lub wartość I<timeout> jest nieprawidłowa."

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "unable to allocate memory for internal tables."
msgstr "nie można było przydzielić pamięci dla wewnętrznych tablic."

#. type: SH
#, no-wrap
msgid "VERSIONS"
msgstr "WERSJE"

#. type: Plain text
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, B<pselect>"
"()  was emulated in glibc (but see BUGS)."
msgstr ""
"B<pselect>() został dodany w wersji 2.6.16 jądra Linuksa. Wcześniej "
"B<pselect>() był emulowany w glibc (patrz również BŁĘDY IMPLEMENTACJI)."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "ZGODNE Z"

#. type: Plain text
msgid ""
"B<select>()  conforms to POSIX.1-2001 and 4.4BSD (B<select>()  first "
"appeared in 4.2BSD).  Generally portable to/from non-BSD systems supporting "
"clones of the BSD socket layer (including System V variants).  However, note "
"that the System V variant typically sets the timeout variable before exit, "
"but the BSD variant does not."
msgstr ""
"B<select>() jest zgodny z POSIX.1-2001 i BSD 4.4 (funkcja B<select>() "
"pojawiła się pierwotnie w BSD 4.2). W ogólności jest przenośne do/z systemów "
"nie-BSD wspierających sklonowaną warstwę gniazd BSD (włączając warianty "
"Systemu V). Jednakże należy zauważyć, że warianty Systemu V zasadniczo "
"ustawiają zmienną timeout przed zakończeniem, ale wariant BSD tego nie robi."

#. type: Plain text
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001."
msgstr "B<pselect>() jest zdefiniowany w POSIX.1g i w POSIX.1-2001."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "UWAGI"

#. type: Plain text
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""
"I<fd_set> jest buforem o stałym rozmiarze. Wykonanie B<FD_CLR>() lub "
"B<FD_SET>() z ujemną wartością I<fd> albo z wartością większą lub równą "
"B<FD_SETSIZE> spowoduje zachowanie niezdefiniowane. Ponadto POSIX wymaga, by "
"I<fd> był prawidłowym deskryptorem pliku."

#. type: Plain text
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1-2001 "
"situation is"
msgstr ""
"Jeśli chodzi o używane typy, klasyczna sytuacja polega na tym, że oba pola "
"struktury I<timeval> są typu I<long> (jak pokazano powyżej), a sama "
"struktura jest zdefiniowana w I<E<lt>sys/time.hE<gt>>. W POSIX.1-2001 "
"wygląda to następująco:"

#. type: Plain text
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t         tv_sec;     /* sekundy */\n"
"    suseconds_t    tv_usec;    /* mikrosekundy */\n"
"};\n"

#. type: Plain text
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""
"przy czym struktura jest zdefiniowana w I<E<lt>sys/select.hE<gt>>, a typy "
"I<time_t> i I<suseconds_t> zdefiniowano w I<E<lt>sys/types.hE<gt>>."

#. type: Plain text
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1-2001 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""
"Jeśli chodzi o prototypy opisywanych funkcji, to klasyczna sytuacja polega "
"na tym, że dla B<select>() należy włączyć I<E<lt>time.hE<gt>>, natomiast "
"sytuacja z POSIX 1003.1-2001 polega na tym, że dla B<select>() i B<pselect>"
"() należy włączyć I<E<lt>sys/select.hE<gt>>. "

#. type: Plain text
msgid ""
"Libc4 and libc5 do not have a I<E<lt>sys/select.hE<gt>> header; under glibc "
"2.0 and later this header exists.  Under glibc 2.0 it unconditionally gives "
"the wrong prototype for B<pselect>().  Under glibc 2.1 to 2.2.1 it gives "
"B<pselect>()  when B<_GNU_SOURCE> is defined.  Since glibc 2.2.2 the "
"requirements are as shown in the SYNOPSIS."
msgstr ""
"Libc4 i libc5 nie zawierają pliku nagłówkowego I<E<lt>sys/select.hE<gt>>; "
"ten plik nagłówkowy istnieje w glibc 2.0 i późniejszych. W glibc 2.0 "
"udostępnia on bezwarunkowo błędny prototyp dla B<pselect>(). W glibc 2.1 aż "
"do 2.2.1 udostępnia on B<pselect>(), jeżeli zdefiniowane jest "
"B<_GNU_SOURCE>. Od glibc 2.2.2 wymagania są takie, jak pokazano powyżej w "
"rozdziale SKŁADNIA."

#. type: SS
#, no-wrap
msgid "Linux Notes"
msgstr "Uwagi linuksowe"

#. type: Plain text
msgid ""
"The Linux B<pselect>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""
"Wywołanie systemowe B<pselect>() pod Linuksem modyfikuje argument "
"I<timeout>. Jednakże funkcja glibc ukrywa to zachowanie przez użycie dla "
"argumentu timeout lokalnej zmiennej, która jest przekazywana do wywołania "
"systemowego. Dlatego B<pselect>() z glibc nie zmienia argumentu I<timeout>, "
"co jest zachowaniem wymaganym przez POSIX.1-2001."

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "BŁĘDY IMPLEMENTACJI"

#. type: Plain text
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""
"Glibc 2.0 dostarczała wersję B<pselect>(), która nie przyjmowała argumentu "
"I<sigmask>."

#. type: Plain text
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that B<pselect>"
"()  was designed to prevent.  Modern versions of glibc use the (race-free)  "
"B<pselect>()  system call on kernels where it is provided."
msgstr ""
"Od wersji 2.1 glibc dostarczał emulację B<pselect>(), która była "
"zaimplementowana przy użyciu B<sigprocmask>(2) i B<select>(). Implementacja "
"ta pozostaje podatna na wiele błędów wyścigów (race conditions), których "
"uniknięcie stanowiło ideę funkcji B<pselect>(). Nowsze wersje glibc używają "
"(wolnego od wyścigów) wywołania systemowego, jeśli tylko jądro dostarcza "
"takiego wywołania."

#. type: Plain text
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick (where a signal handler "
"writes a byte to a pipe whose other end is monitored by B<select>()  in the "
"main program.)"
msgstr ""
"W systemach, które nie mają B<pselect>() niezawodne (i bardziej przenośne) "
"przechwytywanie sygnałów można osiągnąć, używając triku potoku do siebie "
"(gdzie procedura obsługi sygnału zapisuje bajt do potoku, którego drugi "
"koniec jest monitorowany przez B<select>() w głównym programie)."

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""
"Pod Linuksem B<select>() może raportować deskryptory plików gniazd jako "
"\"dostępne do czytania\", podczas gdy kolejne czytania zostaną zablokowane. "
"Może to się zdarzyć na przykład wtedy, gdy dane nadeszły, ale podczas "
"sprawdzania okazało się, że mają złą sumę kontrolną i zostały odrzucone. "
"Mogą wystąpić także inne sytuacje, w których deskryptor pliku jest błędnie "
"raportowany jako gotowy. Dlatego używanie B<O_NONBLOCK> na gniazdach, które "
"nie powinny się blokować może być bezpieczniejsze."

#. type: Plain text
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1-2001.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""
"Pod Linuksem wywołanie B<select>() zmienia wartość I<timeout> także wtedy, "
"gdy zostanie przerwane przez procedurę obsługi sygnału (tj. zostanie "
"zwrócony błąd B<EINTR>). POSIX.1-2001 nie pozwala na takie zachowanie. "
"Wywołanie systemowe B<pselect>() pod Linuksem zachowuje się tak samo, ale "
"funkcja opakowująca biblioteki glibc ukrywa to zachowanie, kopiując wartość "
"I<timeout> do wewnętrznej lokalnej zmiennej i przekazując tę zmienną do "
"wywołania systemowego."

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "PRZYKŁAD"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /* Watch stdin (fd 0) to see when it has input. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""
"    /* Obserwacja stdin (fd 0) i sprawdzanie kiedy ma wejście. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /* Wait up to five seconds. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""
"    /* Czekanie nie dłużej niż 5 sekund. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Nie należy już polegać na wartości tv! */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Dane są już dostępne.\\en\");\n"
"        /* FD_ISSET(0, &rfds) będzie prawdziwy. */\n"
"    else\n"
"        printf(\"Brak danych w ciągu 5 sekund.\\en\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "ZOBACZ TAKŻE"

#. type: Plain text
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr "Samouczek z dyskusją i przykładami znajduje się w B<select_tut>(2)."

#. type: Plain text
msgid ""
"For vaguely related stuff, see B<accept>(2), B<connect>(2), B<poll>(2), "
"B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>"
"(7), B<time>(7)"
msgstr ""
"Rzeczy w nieokreślony sposób powiązane z tym można znaleźć w B<accept>(2), "
"B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>"
"(2), B<write>(2), B<epoll>(7), B<time>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "O STRONIE"

#. type: Plain text
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Angielska wersja tej strony pochodzi z wydania 3.40 projektu Linux I<man-"
"pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
"znaleźć pod adresem http://www.kernel.org/doc/man-pages/."

#~ msgid "2006-03-11"
#~ msgstr "2006-03-11"

#~ msgid "Linux 2.6.16"
#~ msgstr "Linux 2.6.16"

#~ msgid ""
#~ "B<#define _XOPEN_SOURCE 600>\n"
#~ "B<#include E<lt>sys/select.hE<gt>>\n"
#~ msgstr ""
#~ "B<#define _XOPEN_SOURCE 600>\n"
#~ "B<#include E<lt>sys/select.hE<gt>>\n"

#~ msgid ""
#~ "    return 0;\n"
#~ "}\n"
#~ msgstr ""
#~ "    return 0;\n"
#~ "}\n"

#~ msgid "B<pselect>()  was added to Linux in kernel 2.6.16."
#~ msgstr "B<pselect>() został dodany do jadra Linuksa 2.6.16."

#~ msgid "LINUX NOTES"
#~ msgstr "UWAGI LINUKSOWE"
