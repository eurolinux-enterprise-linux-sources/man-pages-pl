# Polish translation of getline.3 man page
# This file is distributed under the same license as original manpage
# Copyright of the original manpage:
# Copyright © 2001 John Levon ("manpages-1")
# Copyright © of Polish translation:
# Andrzej Krzysztofowicz (PTM) <ankry@mif.pg.gda.pl>, 2001.
# Robert Luberda <robert@debian.org>, 2006, 2012.
msgid ""
msgstr ""
"Project-Id-Version: manpages-pl\n"
"POT-Creation-Date: 2012-05-13 19:07+0300\n"
"PO-Revision-Date: 2012-04-01 18:46+0200\n"
"Last-Translator: Robert Luberda <robert@debian.org>\n"
"Language-Team: Polish <manpages-pl-list@lists.sourceforge.net>\n"
"Language: pl\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 1.2\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
"|| n%100>=20) ? 1 : 2);\n"

#. type: TH
#, no-wrap
msgid "GETLINE"
msgstr "GETLINE"

#. type: TH
#, no-wrap
msgid "2010-06-12"
msgstr "2010-06-12"

#. type: TH
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Podręcznik programisty Linuksa"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "NAZWA"

#. type: Plain text
msgid "getline, getdelim - delimited string input"
msgstr "getline, getdelim - wprowadzanie łańcuchów rozgraniczonych"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "SKŁADNIA"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Wymagane ustawienia makr biblioteki glibc (patrz B<feature_test_macros>(7)):"

#. type: Plain text
msgid "B<getline>(), B<getdelim>():"
msgstr "B<getline>(), B<getdelim>():"

#. type: TP
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Od glibc 2.10:"

#. type: Plain text
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"

#. type: TP
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "Przed glibc 2.10:"

#. type: Plain text
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "OPIS"

#. type: Plain text
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is null-"
"terminated and includes the newline character, if one was found."
msgstr ""
"B<getline>() odczytuje całą linię ze strumienia I<stream>, przechowując "
"adres bufora zawierającego tekst w I<*lineptr>. Bufor jest zakończony "
"znakiem NULL i zawiera znak nowej linii, jeśli go napotkano."

#. type: Plain text
msgid ""
"If I<*lineptr> is NULL, then B<getline>()  will allocate a buffer for "
"storing the line, which should be freed by the user program.  (In this case, "
"the value in I<*n> is ignored.)"
msgstr ""
"Gdy I<*lineptr> jest równe NULL, to funkcja B<getline>() przydziela bufor "
"dla umieszczenia w nim zawartości linii, który to bufor musi zostać "
"zwolniony przez program użytkownika (w takim przypadku wartość I<*n> jest "
"ignorowana)."

#. type: Plain text
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr ""
" Alternatywnie, przed wywołaniem B<getline>() I<*lineptr> może zawierać "
"wskaźnik do bufora przydzielonego za pomocą B<malloc>() o rozmiarze I<*n> "
"bajtów. Gdy rozmiar bufora nie jest wystarczający do umieszczenia w nim "
"odczytanej linii, B<getline>() rozszerzy go do odpowiedniego rozmiaru za "
"pomocą B<realloc>(), modyfikując I<*lineptr> i I<*n>, jeśli będzie to "
"potrzebne. "

#. type: Plain text
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr ""
"W każdym razie, po pomyślnym wywołaniu I<*lineptr> i I<*n> będą "
"zaktualizowane tak, aby odzwierciedlić, odpowiednio, adres i rozmiar bufora."

#. type: Plain text
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr ""
"B<getdelim>() działa jak B<getline>(), z tym wyjątkiem że jako argument "
"I<delimiter> można podać ogranicznik linii inny niż znak nowej linii. "
"Podobnie jak dla B<getline>(), znak ogranicznika nie jest dodawany, gdy nie "
"występował w danych wejściowych przed osiągnięciem końca pliku. "

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "WARTOŚĆ ZWRACANA"

#. type: Plain text
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters "
"read, including the delimiter character, but not including the terminating "
"null byte.  This value can be used to handle embedded null bytes in the line "
"read."
msgstr ""
"Po pomyślnym zakończeniu, B<getline>() i B<getdelim>() zwracają liczbę "
"odczytanych znaków, łącznie ze znakiem ogranicznika, ale nie włączając "
"kończącego bajtu null. Wartość ta może służyć to wychwycenia znaków null "
"zawartych w odczytanej linii."

#. type: Plain text
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition)."
msgstr ""
"Obie funkcje zwracają -1, gdy nie uda się odczytać linii (włączając w to "
"próbę czytania na końcu pliku)."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "BŁĘDY"

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr ""
"Błędne wartości parametrów (I<n> lub I<lineptr> równe NULL lub nieprawidłowy "
"I<stream>)."

#. type: SH
#, no-wrap
msgid "VERSIONS"
msgstr "WERSJE"

#. type: Plain text
msgid "These functions are available since libc 4.6.27."
msgstr "Powyższe funkcje są dostępne od libc 4.6.27."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "ZGODNE Z"

#. type: Plain text
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr ""
"Zarówno B<getline>(), jak i B<getdelim>() są rozszerzeniami GNU. Zostały "
"dołączone do standardu POSIX.1-2008."

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "PRZYKŁAD"

#. type: Plain text
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t read;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t read;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    fp = fopen(\"/etc/motd\", \"r\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    fp = fopen(\"/etc/motd\", \"r\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    while ((read = getline(&line, &len, fp)) != -1) {\n"
"        printf(\"Retrieved line of length %zu :\\en\", read);\n"
"        printf(\"%s\", line);\n"
"    }\n"
msgstr ""
"    while ((read = getline(&line, &len, fp)) != -1) {\n"
"        printf(\"Pobrano linię o długości %zu :\\en\", read);\n"
"        printf(\"%s\", line);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    free(line);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(line);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "ZOBACZ TAKŻE"

#. type: Plain text
msgid ""
"B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<gets>(3), B<scanf>(3)"
msgstr ""
"B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<gets>(3), B<scanf>(3)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "O STRONIE"

#. type: Plain text
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Angielska wersja tej strony pochodzi z wydania 3.40 projektu Linux I<man-"
"pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
"znaleźć pod adresem http://www.kernel.org/doc/man-pages/."

#~ msgid "2006-05-17"
#~ msgstr "2006-05-17"

#~ msgid ""
#~ "int main(void)\n"
#~ "{\n"
#~ "\tFILE * fp;\n"
#~ "\tchar * line = NULL;\n"
#~ "\tsize_t len = 0;\n"
#~ "\tssize_t read;\n"
#~ "\tfp = fopen(\"/etc/motd\", \"r\");\n"
#~ "\tif (fp == NULL)\n"
#~ "\t\texit(EXIT_FAILURE);\n"
#~ "\twhile ((read = getline(&line, &len, fp)) != -1) {\n"
#~ "\t\tprintf(\"Retrieved line of length %zu :\\en\", read);\n"
#~ "\t\tprintf(\"%s\", line);\n"
#~ "\t}\n"
#~ "\tif (line)\n"
#~ "\t\tfree(line);\n"
#~ "\treturn EXIT_SUCCESS;\n"
#~ "}\n"
#~ msgstr ""
#~ "int main(void)\n"
#~ "{\n"
#~ "\tFILE * fp;\n"
#~ "\tchar * line = NULL;\n"
#~ "\tsize_t len = 0;\n"
#~ "\tssize_t read;\n"
#~ "\tfp = fopen(\"/etc/motd\", \"r\");\n"
#~ "\tif (fp == NULL)\n"
#~ "\t\texit(EXIT_FAILURE);\n"
#~ "\twhile ((read = getline(&line, &len, fp)) != -1) {\n"
#~ "\t\tprintf(\"Odczytano linię o długości %zu :\\en\", read);\n"
#~ "\t\tprintf(\"%s\", line);\n"
#~ "\t}\n"
#~ "\tif (line)\n"
#~ "\t\tfree(line);\n"
#~ "\treturn EXIT_SUCCESS;\n"
#~ "}\n"
