.rn '' }`
''' $RCSfile: perlop.1,v $$Revision: 1.7 $$Date: 2000/10/22 16:15:28 $
'''
''' $Log: perlop.1,v $
''' Revision 1.7  2000/10/22 16:15:28  wojtek2
''' wiod±ce (spacje, zera etc.)->pocz±tkowe
''' kontrolne (znaki, sekwencje)->steruj±ce
''' tak¿e "klawisze kontrolne" (Ctrl+klaw.)->klawisze steruj±ce
'''
''' Revision 1.6  1999/08/06 10:51:05  wojtek2
''' Pokuta: napis->³añcuch
''' rekursja->rekurencja
''' inne drobne
'''
''' Revision 1.5  1999/08/03 11:07:22  wojtek2
''' bistable->dwustanowy
''' przewa¿niei " xx rather than yy" -> "xx zamiast yy"
'''
''' Revision 1.4  1999/08/02 12:08:52  pborys
''' string->napis
''' shell->pow³oka
''' kernel->j±dro
'''
''' Revision 1.3  1999/07/31 19:18:55  pborys
''' zmiana slashy na uko¶niki
'''
''' Revision 1.2  1999/07/31 15:27:30  pborys
''' korekszkenz
'''
''' Revision 1.1  1999/07/31 12:04:58  pborys
''' slownik -- s³ownik, narazie niech bêdzie w PTM, ew. pó¼niej zrobi siê
''' osobne repozytorium. Poddajê pod ew. dyskusjê jego format itp. (póki jest
''' ma³y :)
''' perlop.1 -- wersja beta, narazie skoñczy³em t³umaczyæ, ale jeszcze nie
''' przegl±da³em, a od b³êdów pewnie siê tam roi :(
'''
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLOP 1 "perl 5.004, patch 01" "7/Jun/97" "Podrêcznik programisty perla"
.IX Title "PERLOP 1"
.UC
.IX Name "perlop - Perl operators and precedence"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAZWA"
.IX Header "NAME"
perlop \- operatory perla i priorytety
.SH "STRESZCZENIE"
.IX Header "SYNOPSIS"
Operatory perla maj± nastêpuj±ce zwi±zki i priorytety, wymienione od
najwy¿szych do najni¿szych. Zauwa¿, ¿e wszystkie operatory po¿yczone z C
zachowuj± tamtejsze zwi±zki, choæ te konwencje s± trochê skopane.
(U³atwia to naukê perla programistom C.) Poza paroma wyj±tkami, wszystkie
one operuj± na warto¶ciach skalarnych, nie tablicowych.
.PP
.Vb 24
\&    lewe        wyra¿enia i lewostronne operatory list
\&    lewe        ->
\&    niezwi±zane ++ --
\&    prawe       **
\&    prawe       ! ~ \e and jednoargumentowy + and -
\&    lewe        =~ !~
\&    lewe        * / % x
\&    lewe        + - .
\&    lewe        << >>
\&    niezwi±zane nazwane operatory jednoargumentowe
\&    niezwi±zane < > <= >= lt gt le ge
\&    niezwi±zane == != <=> eq ne cmp
\&    lewe        &
\&    lewe        | ^
\&    lewe        &&
\&    lewe        ||
\&    niezwi±zane ..  ...
\&    prawe       ?:
\&    prawe       = += -= *= etc.
\&    lewe        , =>
\&    niezwi±zane prawostronne operatory list
\&    prawe       not
\&    lewe        and
\&    lewe        or xor
.Ve
W nastêpuj±cych sekcjach, operatory te s± opisane w kolejno¶ci
priorytetowej.
.SH "OPIS"
.IX Header "DESCRIPTION"
.Sh "Wyra¿enia i lewostronne operatory list"
.IX Subsection "Terms and List Operators (Leftward)"
Wyra¿enie ma w perlu najwy¿szy priorytet. S± to zmienne, cytaty,
operatory w rodzaju cytatów, dowolne wyra¿enie w nawiasach, i dowolna
funkcja, której argumenty s± umieszczone w nawiasach. W rzeczywisto¶ci, w
perlu nie ma tak naprawdê funkcji w ogólnym sensie, s± tylko operatory
listowe i operatory jednoargumentowe, zachowuj±ce siê jak funkcje, bo
ustawiasz wokó³ nich nawiasy. S± one opisane w podrêczniku
\fIperlfunc\fR(1).
.PP
Je¶li dowolny operator listowy (\fIprint()\fR itp.), lub dowolny operator
jednoargumentowy (\fIchdir()\fR) ma za sob± lewy nawias, to operator i
argumenty z nawiasów s± brane w najwy¿szym priorytecie, tak jak przy
normalnym wywo³aniu funkcji.
.PP
Gdy nawiasy nie s± podane, priorytet operatorów listowych w rodzaju
\f(CWprint\fR, \f(CWsort\fR, lub \f(CWchmod\fR 
jest albo bardzo wysoki, albo bardzo niski, zale¿nie od tego czy patrzysz na
lew± stronê, czy na praw± stronê operatora.
Na przyk³ad w
.PP
.Vb 2
\&    @ary = (1, 3, sort 4, 2);
\&    print @ary;         # drukuje 1324
.Ve
przecinki po prawej stronie sort-a s± analizowane przed sortowaniem, lecz
przecinki po lewej s± analizowane pó¼niej. Innymi s³owy, operatory listowe
po¿eraj± wszystkie argumenty, które za nimi nastêpuj±, a potem zachowuj± siê
jak proste wyra¿enie, szanuj±ce wyra¿enie poprzedzaj±ce.
Zauwa¿, ¿e musisz byæ ostro¿ny z nawiasami:
.PP
.Vb 3
\&    # Wykonuj± exit przed drukowaniem:
\&    print($foo, exit);  # raczej nie to, czego chcesz
\&    print $foo, exit;   # ani to
.Ve
.Vb 4
\&    # Te drukuj± przed wykonaniem exit
\&    (print $foo), exit; # To jest to czego chcesz
\&    print($foo), exit;  # to te¿
\&    print ($foo), exit; # nawet to
.Ve
Zauwa¿ te¿, ¿e
.PP
.Vb 1
\&    print ($foo & 255) + 1, "\en";
.Ve
Prawdopodobnie nie robi tego, co oczekujesz. Zobacz sekcjê o nazwanych
operatorach jednoargumentowych.
.PP
Ponadto, jako wyra¿enia przetwarzane s± te¿ konstrukcje \f(CWdo {}\fR i
\f(CWeval {}\fR, a tak¿e wywo³ania podprocedur i metod, oraz anonimowe
konstruktory \f(CW[]\fR i \f(CW{}\fR.
.PP
Zobacz te¿ sekcjê o operatorach cytowania, a tak¿e sekcjê o operatorach I/O.
.Sh "Operator strza³ki"
.IX Subsection "The Arrow Operator"
Podobnie jak w C i \*(C+, \*(L"\f(CW->\fR\*(R" jest operatorem dereferencji.
Je¶li prawa strona to element \f(CW[...]\fR lub \f(CW{...}\fR, to lewa
strona musi byæ tward±, lub symboliczn± referencj± do tablicy, lub tablicy
asocjacyjnej (lub miejsca, które jest w stanie przechowywaæ tward±
referencjê, je¶li jest to lwarto¶æ (przypisywalna)). Zobacz stronê
\fIperlref\fR(1).
.PP
W przeciwnym wypadku, prawa strona jest nazw± metody, lub prost± zmienn±
skalarn±, zawieraj±c± nazwê metody, a lewa strona musi byæ albo obiektem
(pob³ogos³awion± przez bless referencj±), lub nazw± klasy (tj. nazw±
pakietu).
Zobacz stronê \fIperlobj\fR(1).
.Sh "Auto-inkrementacja i Auto-dekrementacja"
.IX Subsection "Auto-increment and Auto-decrement"
\*(L"++\*(R" i \*(L"--\*(R" dzia³aj± jak w C. To znaczy, je¶li s±
umieszczone przed zmienn±, to inkrementuj± lub dekrementuj± zmienn± przed
zwróceniem warto¶ci, a je¶li s± umieszczone za zmienn±, to powoduj±
inkrementacjê lub dekrementacjê po zwróceniu warto¶ci.
.PP
Operator auto-inkrementacji ma wbudowanych parê dodatkowych rzeczy. Je¶li
inkrementujesz zmienn±, która jest numeryczna, lub która by³a kiedykolwiek
u¿yta w kontek¶cie numerycznym, to uzyskasz normaln± inkrementacjê. Jednak
je¶li zmienna by³a u¿ywana tylko w kontekstach ³añcuchowych, a jej warto¶æ
nie jest nullem i odpowiada wzorcowi
\f(CW/^[a-zA-Z]*[0-9]*$/\fR, 
to inkrementacja jest dokonywana jak na ³añcuchu, zachowuj±c ka¿dy znak w
zakresie, z przeniesieniem:
.PP
.Vb 4
\&    print ++($foo = '99');      # drukuje '100'
\&    print ++($foo = 'a0');      # drukuje 'a1'
\&    print ++($foo = 'Az');      # drukuje 'Ba'
\&    print ++($foo = 'zz');      # drukuje 'aaa'
.Ve
Operator autodekrementacji nie ma tych w³a¶ciwo¶ci.
.Sh "Potêga"
.IX Subsection "Exponentiation"
Binarny \*(L"**\*(R" jest operatorem potêgowania. Zauwa¿, ¿e ³±czy mocniej
ni¿ jednoargumentowy minus, wiêc \-2**4 to \-(2**4), a nie (\-2)**4. 
(Jest to zaimplementowane przy u¿yciu funkcji
\fIpow\fR\|(3) z C, która w rzeczywisto¶ci dzia³a na liczbach typu podwójnej
precyzji.)
.Sh "Symboliczne operatory jednoargumentowe"
.IX Subsection "Symbolic Unary Operators"
Jednoargumentowy \*(L"!\*(R" 
wykonuje negacjê logiczn±, czyli \*(L"not\*(R".  
Zobacz te¿ \f(CWnot\fR dla wersji o ni¿szym priorytecie.
.PP
Jednoargumentowy \*(L"\-\*(R" dokonuje arytmetycznej negacji na numerycznym
operandzie. Je¶li operand jest identyfikatorem, zwracany jest ³añcuch
sk³adaj±cy siê ze znaku minus i z identyfikatora.
W przeciwnym wypadku, je¶li ³añcuch rozpoczyna siê
znakiem plus lub minus, zwracany jest ³añcuch z przeciwnym znakiem. Jednym z
efektów tego dzia³ania jest to, ¿e \f(CW-bareword\fR jest równowa¿ne
\f(CW"-bareword"\fR.
.PP
Jednoargumentowy \*(L"~\*(R" dokonuje negacji bitowej.
(Zobacz te¿ sekcjê o arytmetyce ca³kowitej.)
.PP
Jednoargumentowy \*(L"+\*(R" 
nie daje ¿adnego efektu, nawet na ³añcuchach. Jest przydatny do rozdzielania
nazwy funkcji od otoczonego nawiasami wyra¿enia, które w przeciwnym wypadku
by³oby interpretowane jako ca³kowita lista argumentów funkcji. (Zobacz
przyk³ady w sekcji o wyra¿eniach i lewostronnych operatorach listowych.)
.PP
Jednoargumentowy \*(L"\e\*(R" tworzy referencjê do tego, co po nim
nastêpuje. Zobacz podrêcznik \fIperlref\fR(1).
Nie myl tego zachowania z zachowaniem w ³añcuchu odwrotnego uko¶nika, choæ obie
postacie maj± tê sam± w³a¶ciwo¶æ chronienia nastêpnej rzeczy od
interpretacji.
.Sh "Operatory ³±czenia"
.IX Subsection "Binding Operators"
Binarny \*(L"=~\*(R" ³±czy wyra¿enie skalarne z obs³ug± wyra¿enia
regularnego. 
Pewne operacje domy¶lnie szukaj± lub zmieniaj± ³añcuch \f(CW$_\fR.
Operator ten powoduje, ¿e taka operacja dzia³a na innym ³añcuchu. Prawy
argument jest wzorcem przeszukiwania, podstawienia lub translacji. Lewy
argument jest przeszukiwanym ³añcuchem, zamiast domy¶lnego \f(CW$_\fR.
Warto¶æ zwracana okre¶la sukces operacji. (Je¶li prawy argument jest raczej
wyra¿eniem ni¿ wzorcem przeszukiwania, podstawiania lub translacji, to jest
interpretowany jako wzorzec przeszukiwania czasu dzia³ania. Mo¿e to byæ
mniej efektywne ni¿ jawne szukanie, gdy¿ wzorzec musi byæ za ka¿dym razem
kompilowany. 
.PP
[Przyp. t³um: Na przyk³ad "$lancuch="bla"; $lancuch=~s/l/q/; print $lancuch" da w
wyniku ³añcuch "bqa".]
.PP
Binarny \*(L"!~\*(R" jest podobny do \*(L"=~\*(R" lecz warto¶æ zwracana jest
logicznie negowana.
.Sh "Operatory mno¿enia"
.IX Subsection "Multiplicative Operators"
Binarny \*(L"*\*(R" mno¿y dwie liczby.
.PP
Binarny \*(L"/\*(R" dzieli dwie liczby.
.PP
Binarny \*(L"%\*(R" oblicza resztê (modulo) z dwóch liczb. Z ca³kowitymi
operandami \f(CW$a\fR i \f(CW$b\fR: je¶li \f(CW$b\fR jest dodatnie, to
\f(CW$a % $b\fR to \f(CW$a\fR minus najwiêksza wielokrotno¶æ \f(CW$b\fR,
która nie jest wiêksza od
\f(CW$a\fR.  Je¶li \f(CW$b\fR jest ujemne, to \f(CW$a % $b\fR to \f(CW$a\fR 
minus najmniejsza wielokrotno¶æ \f(CW$b\fR, która nie jest mniejsza ni¿
\f(CW$a\fR (np. wynik bêdzie mniejszy lub równy od zera).
.PP
Binarny \*(L"x\*(R" jest operatorem powtórzenia.
W kontek¶cie skalarnym, zwraca ³añcuch sk³adaj±cy siê z lewego operanda,
powtórzonego tyle razy, ile podano w prawym. W kontek¶cie listowym, je¶li
lewy operand jest list± w nawiasach, powtarzana jest lista.
.PP
.Vb 1
\&    print '-' x 80;             # wydrukuj wiersz kresek
.Ve
.Vb 1
\&    print "\et" x ($tab/8), ' ' x ($tab%8);      # tabuluj poprzez
.Ve
.Vb 2
\&    @ones = (1) x 80;           # lista 80 jedynek
\&    @ones = (5) x @ones;        # ustaw wszystkie elementy na 5
.Ve
.Sh "Operatory dodawania"
.IX Subsection "Additive Operators"
Binarny \*(L"+\*(R" zwraca sumê dwóch liczb.
.PP
Binarny \*(L"\-\*(R" zwraca ró¿nicê dwóch liczb.
.PP
Binarny \*(L".\*(R" ³±czy (konkatenuje) ³añcuchy.
.Sh "Operatory przesuwania"
.IX Subsection "Shift Operators"
Binanry \*(L"<<\*(R" zwraca warto¶æ swojego lewego argumentu, przesuniêtego
w lewo o ilo¶æ bitów, podan± w prawym argumencie. Argumenty powinny byæ
liczbami ca³kowitymi. (Zobacz te¿ sekcjê o arytmetyce ca³kowitej.)
.PP
Binarny \*(L">>\*(R" zwraca warto¶æ swojego lewego argumentu, przesuniêtego
w prawo o ilo¶æ bitów, podan± w prawym argumencie. Argumenty powinny byæ
liczbami ca³kowitymi.
.Sh "Nazwane operatory jednoargumentowe"
.IX Subsection "Named Unary Operators"
Ró¿ne nazwane operatory jednoargumentowe s± traktowane jak jednoargumentowe
funkcje, z opcjonalnymi nawiasami. S± to m.in testy plikowe, itp. Zobacz
podrêcznik \fIperlfunc\fR(1).
.PP
Je¶li za dowolnym operatorem listowym (\fIprint()\fR itp.), lub operatorem
jednoargumentowym (\fIchdir()\fR itp.) nastêpuje lewy nawias, to operator i
argumenty w nawiasach s± brane z najwy¿szym priorytetem, tak jak przy
wywo³aniu funkcji. Przyk³ady:
.PP
.Vb 4
\&    chdir $foo    || die;       # (chdir $foo) || die
\&    chdir($foo)   || die;       # (chdir $foo) || die
\&    chdir ($foo)  || die;       # (chdir $foo) || die
\&    chdir +($foo) || die;       # (chdir $foo) || die
.Ve
lecz poniewa¿ * ma wy¿szy priorytet ni¿ ||:
.PP
.Vb 4
\&    chdir $foo * 20;    # chdir ($foo * 20)
\&    chdir($foo) * 20;   # (chdir $foo) * 20
\&    chdir ($foo) * 20;  # (chdir $foo) * 20
\&    chdir +($foo) * 20; # chdir ($foo * 20)
.Ve
.Vb 4
\&    rand 10 * 20;       # rand (10 * 20)
\&    rand(10) * 20;      # (rand 10) * 20
\&    rand (10) * 20;     # (rand 10) * 20
\&    rand +(10) * 20;    # rand (10 * 20)
.Ve
Zobacz te¿ sekcjê o wyra¿eniach i lewostronnych operatorach listowych.
.Sh "Operatory relacji"
.IX Subsection "Relational Operators"
Binarny \*(L"<\*(R" zwraca prawdê, je¶li lewy argument jest numerycznie
mniejszy ni¿ prawy.
.PP
Binarny \*(L">\*(R" zwraca prawdê, je¶li lewy argument jest numerycznie
wiêkszy ni¿ prawy.
.PP
Binarny \*(L"<=\*(R" zwraca prawdê, je¶li lewy argument jest numerycznie
mniejszy lub równy prawemu.
.PP
Binarny \*(L">=\*(R" zwraca prawdê, je¶li lewy argument jest numerycznie
wiêkszy lub równy prawemu.
.PP
Binarny \*(L"lt\*(R" zwraca prawdê, je¶li lewy argument jest ³añcuchowo
mniejszy od prawego.
.PP
Binarny \*(L"gt\*(R" zwraca prawdê, je¶li lewy argument jest ³añcuchowo
wiêkszy od prawego.
.PP
Binarny \*(L"le\*(R" zwraca prawdê, je¶li lewy argument jest ³añcuchowo
mniejszy lub równy prawemu.
.PP
Binarny \*(L"ge\*(R" zwraca prawdê, je¶li lewy argument jest ³añcuchowo
wiêkszy lub równy prawemu.
.Sh "Operatory równo¶ci"
.IX Subsection "Equality Operators"
Binarny \*(L"==\*(R" zwraca prawdê, je¶li lewy argument jest numerycznie
równy prawemu.
.PP
Binarny \*(L"!=\*(R" zwraca prawdê, je¶li lewy argument nie jest numerycznie
równy prawemu.
.PP
Binarny \*(L"<=>\*(R" zwraca \-1, 0, lub 1, zale¿nie od tego czy lewy
argument jest numerycznie mniejszy, równy, lub wiêkszy od prawego.
.PP
Binarny \*(L"eq\*(R" zwraca prawdê, je¶li lewy argument jest ³añcuchowo równy
prawemu.
.PP
Binarny \*(L"ne\*(R" zwraca prawdê, je¶li lewy argument nie jest ³añcuchowo
równy prawemu.
.PP
Binarny \*(L"cmp\*(R" zwraca \-1, 0, lub 1, zale¿nie od tego, czy lewy
argument jest ³añcuchowo mniejszy, równy, lub wiêkszy od prawego.
.PP
\*(L"lt\*(R", \*(L"le\*(R", \*(L"ge\*(R", \*(L"gt\*(R" i \*(L"cmp\*(R" 
mog± u¿ywaæ kolejno¶ci sortowania, okre¶lonej przez bie¿±ce locale (gdy
u¿yte jest \f(CWuse locale\fR). Zobacz podrêcznik \fIperllocale\fR(1).
.Sh "Bitowy And"
.IX Subsection "Bitwise And"
Binarny \*(L"&\*(R" zwraca jego operatory, po³±czone bitowo operacj± logiczn± 
AND.
(Zobacz te¿ sekcjê o arytmetyce ca³kowitej.)
.Sh "Bitowy Or i Xor (eXclusive Or)"
.IX Subsection "Bitwise Or and Exclusive Or"
Binarny \*(L"|\*(R" zwraca swoje operatory, po³±czone bitowo operacj±
logiczn± OR. (Zobacz te¿ sekcjê o arytmetyce ca³kowitej).
.PP
Binarny \*(L"^\*(R" zwraca swoje operatory, po³±czone bitowo operacj± XOR.
(Zobacz te¿ sekcjê o arytmetyce ca³kowitej.)
.Sh "Logiczny And w stylu C"
.IX Subsection "C\-style Logical And"
Binarny \*(L"&&\*(R" dokonuje logicznej operacji AND. Je¶li lewy operand
jest fa³szywy (false), to prawy nie jest nawet analizowany. Kontekst
skalarny, lub listowy propaguje do prawego operatora, je¶li jest on
analizowany.
.Sh "Logiczny Or w stylu C"
.IX Subsection "C\-style Logical Or"
Binarny \*(L"||\*(R" dokonuje logicznej operacji OR. To znaczy, ¿e je¶li
lewy operand jest prawdziwy (true), to prawy nie jest nawet analizowany.
Kontekst skalarny, lub listowy propaguje do prawego operatora, je¶li jest on
analizowany.
.PP
Operatory \f(CW||\fR i \f(CW&&\fR ró¿ni± siê od C tym, ¿e zwracaj± ostatni±
analizowan± warto¶æ zamiast 0 czy 1. Tak wiêc przeno¶nym sposobem
znalezienia katalogu domowego (zak³adaj±c, ¿e nie jest \*(L"0"), mo¿e byæ:
.PP
.Vb 2
\&    $home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
\&        (getpwuid($<))[7] || die "You're homeless!\en";
.Ve
Jako czytelniejsze alternatywy \f(CW&&\fR i \f(CW||\fR, 
perl udostêpnia operatory \*(L"and\*(R" i \*(L"or\*(R" (patrz ni¿ej).
Zachowanie jest identyczne. Jednak ich priorytet jest ni¿szy, wiêc mo¿esz
ich bezpiecznie u¿ywaæ po operatorze listowym, bez konieczno¶ci u¿ywania
nawiasów:
.PP
.Vb 2
\&    unlink "alpha", "beta", "gamma"
\&            or gripe(), next LINE;
.Ve
Z u¿yciem operatorów w stylu C, trzeba by by³o to zapisaæ jako:
.PP
.Vb 2
\&    unlink("alpha", "beta", "gamma")
\&            || (gripe(), next LINE);
.Ve
.Sh "Operator zakresu"
.IX Subsection "Range Operator"
Binarny \*(L"..\*(R" jest operatorem zakresu, który jest w rzeczywisto¶ci
dwoma innymi operatorami, zale¿nymi od kontekstu. W kontek¶cie listowym,
zwraca tablicê warto¶ci, liczon± (po jednym) od warto¶ci lewej do prawej.
Jest to przydatne do zapisywania pêtli \f(CWfor (1..10)\fR 
i robienia operacji wycinania (slice) na tablicach.
B±d¼ ¶wiadom, ¿e w bie¿±cej implementacji tworzona jest tymczasowa tablica,
wiêc potrzeba na to trochê pamiêci, je¶li zapiszesz co¶ takiego:
.PP
.Vb 3
\&    for (1 .. 1_000_000) {
\&        # kod
\&    }
.Ve
W kontek¶cie skalarnym, \*(L"..\*(R" zwraca warto¶æ logiczn±. Operator jest
dwustanowy, jak flip-flop i emuluje operator zakresu liniowego (przecinek) z
\fBsed\fR(1), \fBawk\fR(1) i ró¿nych edytorów. Ka¿dy operator \*(L"..\*(R"
obs³uguje swój w³asny stan logiczny. Jest on fa³szywy tak d³ugo, jak d³ugo
lewy operand jest fa³szywy. Gdy lewy operand stanie siê prawdziwy, operator
zakresu pozostaje prawdziwy dopóki prawy argument jest prawd±, PO czym,
operator zakresu przyjmuje warto¶æ fa³szu. (Nie staje siê fa³szywym do
czasu nastêpnej jego analizy. Mo¿e testowaæ prawy operand i staæ siê
fa³szywym w tej samej analizie, kiedy sta³ siê prawdziwym (jak w
\fBawk\fR(1)), lecz wci±¿ bêdzie raz zwraca³ prawdê. Je¶li nie chcesz by
testowa³ prawy operand przed nastêpn± analiz± (jak w \fBsed\fR(1)), u¿yj
trzech kropek (\*(R"...") zamiast dwóch.) Prawy operand nie jest analizowany
podczas gdy operator jest w stanie fa³szu, a lewy operand nie jest
analizowany gdy operator jest w stanie prawdy. Priorytet jest trochê ni¿szy
ni¿ || i &&. Zwracana warto¶æ jest albo ³añcuchem null dla fa³szu, lub
liczb± sekwencyjn± (zaczynaj±c± siê od 1) dla prawdy. Liczba sekwencyjna
jest resetowana dla ka¿dego napotkanego zakresu. Koñcowa liczba
sekwencyjna w zakresie ma doklejony ³añcuch \*(L"E0\*R", który nie ma jednak
wp³ywu na warto¶æ numeryczn±, a za to daje co¶, czego mo¿esz oczekiwaæ na
koñcu. Mo¿esz wy³±czyæ punkt pocz±tkowy przez oczekiwanie a¿ liczba
sekwencyjna stanie siê wiêksza ni¿ jeden. Je¶li który¶ z operandów
skalarnego \*(L"..\*(R" jest litera³em numerycznym, operand jest niejawnie
porównywany ze zmienn± \f(CW$.\fR, bie¿±cym numerem linii.
Przyk³ady
.PP
Jako operator skalarny:
.PP
.Vb 3
\&    if (101 .. 200) { print; }  # wydrukuj drug± setkê linii
\&    next line if (1 .. /^$/);   # pomiñ linie nag³ówka [pocztowego]
\&    s/^/> / if (/^$/ .. eof()); # Cytuj cia³o
.Ve
Jako operator listowy:
.PP
.Vb 3
\&    for (101 .. 200) { print; } # drukuj 100 razy $_ 100
\&    @foo = @foo[0 .. $#foo];    # kosztowny no-op
\&    @foo = @foo[$#foo-4 .. $#foo];      # wytnij ostatnich 5 elementów
.Ve
Operator zakresu (w kontek¶cie listowym) u¿ywa w wypadku gdy operandy s±
³añcuchami magicznego algorytmu autoinkrementacji. Mo¿esz powiedzieæ
.PP
.Vb 1
\&    @alphabet = ('A' .. 'Z');
.Ve
i uzyskaæ tak wszystkie litery alfabetu, lub
.PP
.Vb 1
\&    $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];
.Ve
by uzyskaæ liczby szesnastkowe, lub
.PP
.Vb 1
\&    @z2 = ('01' .. '31');  print $z2[$mday];
.Ve
by uzyskaæ daty z pocz±tkowymi zerami. Je¶li ostatnia podana warto¶æ nie
jest w sekwencji, któr± daje magiczna inkrementacja, to sekwencja idzie tak
daleko, a¿ nastêpna warto¶æ nie bêdzie d³u¿sza ni¿ podana ostatnia warto¶æ.
.Sh "Operator warunkowy"
.IX Subsection "Conditional Operator"
\*(L"?:\*(R" jest operatorem warunkowym, zupe³nie jak w C. Dzia³a podobnie
do konstrukcji if-then-else. Je¶li argument przed ? jest prawdziwy, to
zwracany jest argument przed :. W przeciwnym wypadku, zwracany jest argument
po :. Na przyk³ad:
.PP
.Vb 2
\&    printf "Mam %d ps%s.\en", $n,
\&            ($n == 1) ? "a" : "y";
.Ve
Kontekst skalarny, lub listowy propaguje do 2-giego lub 3-ciego argumentu,
zale¿nie od wyboru.
.PP
.Vb 3
\&    $a = $ok ? $b : $c;  # we¼ skalar
\&    @a = $ok ? @b : @c;  # we¼ tablicê
\&    $a = $ok ? @b : @c;  # oops, to tylko licznik!
.Ve
Operator mo¿e byæ przypisany je¶li obydwa argumenty -- 2-gi i 3-ci s±
legalnymi lwarto¶ciami (co znaczy ¿e mo¿na do nich przypisaæ):
.PP
.Vb 1
\&    ($a_or_b ? $a : $b) = $c;
.Ve
Niekoniecznie musi to jednak poprawiæ czytelno¶æ twojego programu.
.Sh "Operatory przypisania"
.IX Subsection "Assignment Operators"
\*(L"=\*(R" jest zwyk³ym operatorem przypisania.
.PP
Operator przypisania dzia³a jak w C. Tzn,
.PP
.Vb 1
\&    $a += 2;
.Ve
jest równowa¿ne
.PP
.Vb 1
\&    $a = $a + 2;
.Ve
choæ bez powielania efektów ubocznych, które mo¿e poci±gaæ za sob±
dereferencja lwarto¶ci, tak jak dla \fItie()\fR. Inne operatory
przypisania dzia³aj± podobnie. Rozpoznawane s± nastêpuj±ce:
.PP
.Vb 4
\&    **=    +=    *=    &=    <<=    &&=
\&           -=    /=    |=    >>=    ||=
\&           .=    %=    ^=
\&                 x=
.Ve
Zauwa¿, ¿e podczas gdy s± one zgrupowane w rodziny, maj± jednakowy priorytet
przypisania.
.PP
W przeciwieñstwie do C, operator przypisania daje prawid³ow± lwarto¶æ.
Modyfikowanie przypisania jest równowa¿ne do robienia przypisania, a potem
zmieniania przypisanej zmiennej. jest to przydatne do modyfikowania kopii
czego¶, np:
.PP
.Vb 1
\&    ($tmp = $global) =~ tr [A-Z] [a-z];
.Ve
Podobnie,
.PP
.Vb 1
\&    ($a += 2) *= 3;
.Ve
jest równowa¿ne
.PP
.Vb 2
\&    $a += 2;
\&    $a *= 3;
.Ve
.Sh "Operator przecinka"
.IX Subsection "Comma Operator"
Binarny \*(L",\*(R" jest operatorem przecinka. W kontek¶cie skalarnym
analizuje swój lewy argument, wyrzuca jego warto¶æ i nastêpnie analizuje
prawy argument, zwracaj±c jego warto¶æ. Jest to takie samo, jak operator
przecinka z C.
.PP
W kontek¶cie listowym, jest to po prostu separator listy i wstawia obydwa
argumenty do listy.
.PP
Znak => jest czêsto synonimem operatora przecinka. Przydatny jest
do dokumentowania argumentów, które s± w parach. Od wersji 5.001 wymusza to
te¿ interpretacjê ka¿dego s³owa z lewej jako ³añcucha.
.Sh "Operatory listowe (w prawo)"
.IX Subsection "List Operators (Rightward)"
Po prawej stronie operatora listowego, jest niski priorytet, taki ¿e 
kontroluje on wszystkie znalezione tam elementy, oddzielone przecinkami.
Jedyne operatory o ni¿szym priorytecie to operatory logiczne
\*(L"and\*(R", \*(L"or\*(R", i \*(L"not\*(R", które mog± byæ u¿ywane do
analizowania wywo³añ do operatorów listowych, bez potrzeby dodatkowych
nawiasów:
.PP
.Vb 2
\&    open HANDLE, "filename"
\&        or die "Can't open: $!\en";
.Ve
Zobacz te¿ dyskusjê operatorów listowych w sekcji o wyra¿eniach i
operatorach listowych lewostronnych.
.Sh "Logiczny Not"
.IX Subsection "Logical Not"
Jednoargumentowy \*(L"not\*(R" zwraca logiczn± negacjê prawego argumentu.
Jest równowa¿ny \*(L"!\*(R", lecz ma ni¿szy priorytet.
.Sh "Logiczny And"
.IX Subsection "Logical And"
Binarny \*(L"and\*(R" zwraca logiczn± koniunkcjê otaczaj±cych wyra¿eñ. Jest
równowa¿ny &&, lecz ma ni¿szy priorytet. Znaczy to, ¿e prawe wyra¿enie jest
analizowane tylko je¶li lewe jest prawdziwe.
.Sh "Logiczny or i xor"
.IX Subsection "Logical or and Exclusive Or"
Binarny \*(L"or\*(R" zwraca logiczn± dyzjunkcjê otaczaj±cych wyra¿eñ. Jest
równowa¿ny ||, lecz ma ni¿szy priorytet. Znaczy to, ¿e prawe wyra¿enie jest
wykonywane tylko je¶li lewe jest fa³szywe.
.PP
Binarny \*(L"xor\*(R" zwraca \s-1XOR\s0 otaczaj±cych wyra¿eñ.
Nie mo¿e byæ oczywi¶cie u¿ywany z zawê¿eniem, jak or.
.Sh "Operatory C, których brakuje w perlu"
.IX Subsection "C Operators Missing From Perl"
Oto operatory C, których perl nie posiada:
.Ip "jednoargumentowy &" 8
.IX Item "unary &"
Operator adresu. (Lecz zobacz opis operatora \*(L"\e\*(R".)
.Ip "jednoargumentowy *" 8
.IX Item "unary *"
Operator dereferencji (wy³uskania) adresu. (Perlowe przedrostkowe operatory
dereferencji to: $, @, %, &.)
.Ip "(\s-1TYP\s0)" 8
.IX Item "(\s-1TYPE\s0)"
Operator konwersji typów.
.Sh "Operatory cytatów i cytatopodobne"
.IX Subsection "Quote and Quote-like Operators"
Podczas gdy normalnie my¶limy o cytatach jak o literalnych warto¶ciach,
w perlu maj± one funkcjê operatorów, daj±c ró¿ne w³a¶ciwo¶ci interpolowania i
porównywania wzorców.
Perl daje dla tych zachowañ tradycyjne znaki cytowania, lecz równie¿ sposób
na wybieranie znaku cytowania. W nastêpuj±cej tablicy, \f(CW{}\fR 
oznacza parê ograniczników, które wybierzesz. Ograniczniki nienawiasowe u¿ywaj±
tego samego znaku na pocz±tek i koniec, ale 4 rodzaje nawiasów mog± siê
zagnie¿d¿aæ.
.PP
.Vb 8
\&    Zwyczajowy Standardowy Znaczenie    Interpoluje
\&        ''       q{}       Litera³         nie
\&        ""      qq{}       Litera³         tak
\&        ``      qx{}       Komenda         tak
\&                qw{}      Lista s³ów       nie
\&        //       m{} Porównanie ze wzorcem tak
\&                 s{}{}   Podstawienie      tak
\&                tr{}{}   Translacja        nie
.Ve
Dla konstrukcji, wykonuj±cych interpolacjê, zmienne zaczynaj±ce siê od \*(L"\f(CW$\fR\*(R" 
lub \*(L"\f(CW@\fR\*(R" s± interpolowane jako nastêpuj±ce sekwencje:
.PP
.Vb 16
\&    \et          tab             (HT, TAB)
\&    \en          nowalinia       (LF, NL)
\&    \er          return          (CR)
\&    \ef          form feed       (FF)
\&    \eb          backspace       (BS)
\&    \ea          alarm (dzwonek) (BEL)
\&    \ee          escape          (ESC)
\&    \e033        znak ósemkowy
\&    \ex1b        znak szesnastkowy
\&    \ec[         znak steruj±cy
\&    \el          zmieñ nastêpny znak na ma³± literê
\&    \eu          zmieñ nastêpny znak na du¿± literê
\&    \eL          zmieñ na ma³± literê a¿ do \eE
\&    \eU          zmieñ na du¿± literê a¿ do \eE
\&    \eE          koniec modyfikacji rozmiaru
\&    \eQ          cytuj metaznaki regexp a¿ do \eE
.Ve
Je¶li u¿ywane jest \f(CWuse locale\fR, mapa rozmiarów liter odpowiada
lokalnej sytuacji. Zobacz podrêcznik \fIperllocale\fR(1).
.PP
Wzorce s± podstaw± do innego poziomu interpretacji -- jako wyra¿enia
regularne. Jest to robione jako drugi przebieg, po interpolacji zmiennych,
tak ¿e wyra¿enia regularne mog± byæ w³±czane do wzorca ze zmiennych. Je¶li
tego nie chcesz, u¿yj \f(CW\eQ\fR.
.PP
Poza powy¿szym, nie ma wielokrotnych poziomów interpolacji. W
rzeczywisto¶ci, w przeciwieñstwie do oczekiwañ programistów pow³okowych,
odwrotne cudzys³owy nie interpoluj± w podwójnych cudzys³owach, a pojedyncze
otoczone w podwójnych cudzys³owach nie utrudniaj± analizy zmiennych w nich 
zawartych.
.Sh "Operatory cytatopodobne Regexp"
.IX Subsection "Regexp Quote-Like Operators"
Oto cytatopodobne operatory, które dotycz± siê dzia³añ zwi±zanych z
porównywaniem wzorców.
.Ip "?\s-1WZORZEC\s0?" 8
.IX Item "?\s-1PATTERN\s0?"
Jest to co¶ w rodzaju przeszukiwania \f(CW/wzorzec/\fR,
lecz miêdzy wywo³aniami operatora \fIreset()\fR, trafienie jest jednokrotne.
Jest to przydatna optymalizacja, je¶li np. chcesz zobaczyæ tylko pierwsze
pojawienie siê czego¶ w pliku, lub zbiorze.
Resetowane s± tylko wzorce \f(CW??\fR, lokalne dla bie¿±cego pakietu.
.Sp
To u¿ycie jest niezalecane i mo¿e byæ usuniête w przysz³ych wersjach perla.
.Ip "m/\s-1WZORZEC/\s0gimosx" 8
.IX Item "m/\s-1PATTERN/\s0gimosx"
.Ip "/\s-1WZORZEC/\s0gimosx" 8
.IX Item "/\s-1PATTERN/\s0gimosx"
Przeszukuje wzorzec dla trafienia i w kontek¶cie skalarnym wzraca prawdê (1), 
lub fa³sz (''). Je¶li nie podano ¿adnego ³añcucha poprzez operator \f(CW=~\fR,
lub \f(CW!~\fR, przeszukiwany jest ³añcuch \f(CW$_\fR.  
(£añcuch podany przez
\f(CW=~\fR nie musi byæ lwarto¶ci± \*(-- mo¿e byæ wynikiem analizy wyra¿enia,
lecz pamiêtaj, ¿e \f(CW=~\fR wi±¿e do¶æ mocno.) Zobacz te¿ podrêcznik
\fIperlre\fR(1).
Zobacz podrêcznik \fIperllocale\fR(1) dla dyskusji o dodatkowych sprawach,
zwi±zanych z u¿yciem \f(CWuse locale\fR.
.Sp
Opcje to:
.Sp
.Vb 6
\&    g   Porównuj globalnie, na wszystkich pojawieniach
\&    i   Porównuj bez zwracania uwagi na wielko¶æ liter
\&    m   Traktuj ³añcuch jako wielokrotne linie
\&    o   Kompiluj wzorzec tylko raz
\&    s   Traktuj ³añcuch jako pojedyncz± liniê
\&    x   U¿yj rozszerzonych wyra¿eñ regularnych
.Ve
Je¶li ogranicznikiem jest \*(L"/\*(R", to pocz±tkowe \f(CWm\fR jest opcjonalne.  
U¿ywaj±c \f(CWm\fR, mo¿esz wykorzystaæ jako ograniczniki dowoln± parê
nialfanumerycznych, niebia³ospacjowych znaków. Jest to przydatne do
porównywania unixowych nazw ¶cie¿ek, które mog± zawieraæ \*(L"/\*(R".
Zapobiega to \s-1LTS\s0 (syndrom w±skiej wyka³aczki).  Je¶li \*(L"?\*(R" 
jest ogranicznikiem, to stosowana jest regu³a trafienia-tylko-raz instrukcji
\f(CW?WZORZEC?\fR.
.Sp
\s-1WZORZEC\s0 mo¿e zawieraæ zmienne, które bêd± interpolowane (a wzorzec
rekompilowany) za ka¿d± analiz±. (Zauwa¿, ¿e \f(CW$)\fR i \f(CW$|\fR 
mog± nie byæ interpolowane, gdy¿ wygl±daj± jak testy koñca ³añcucha.)
Je¶li chcesz, by takie wzorce by³y kompilowane tylko raz, dodaj do
ostatniego ogranicznika znak \f(CW/o\fR. Zapobiega to kosztownej kompilacji
czasu dzia³ania i jest przydatne, gdy warto¶æ, z której korzystasz nie
zmienia siê w czasie ¿ycia skryptu. Jednak pamiêtaj, ¿e opcja
\f(CW/o\fR daje obietnicê, i¿ nie zmienisz zmiennych ze wzorca.
Je¶li je zmienisz, perl tego nie zauwa¿y.
.Sp
Je¶li \s-1WZORZEC\s0 zostanie zanalizowany jako ³añcuch null, to u¿yte
zostanie ostatnie wykonane wyra¿enie regularne.
.Sp
W kontek¶cie, wymagaj±cym warto¶ci listowej, porównanie wzorca zwraca listê,
sk³adaj±c± siê z listy podwyra¿eñ, trafionych przez nawiasy z wzorca, np.
(\f(CW$1\fR, \f(CW$2\fR, \f(CW$3\fR...).  
(Zauwa¿, ¿e ustawione tu s± równie¿ \f(CW$1\fR itp. i ¿e ró¿ni siê to od
zachowania perla 4.) Je¶li porównanie siê nie powiedzie, zwracana jest
tablica null. Je¶li porównanie siê powiedzie, lecz nie bêdzie nawiasów,
zwracana zostanie warto¶æ listowa (1).
.Sp
Przyk³ady:
.Sp
.Vb 2
\&    open(TTY, '/dev/tty');
\&    <TTY> =~ /^y/i && foo();    # zrób foo, je¶li trzeba
.Ve
.Vb 1
\&    if (/Version: *([0-9.]*)/) { $version = $1; }
.Ve
.Vb 1
\&    next if m#^/usr/spool/uucp#;
.Ve
.Vb 5
\&    # grep biedaka
\&    $arg = shift;
\&    while (<>) {
\&        print if /$arg/o;       # kompiluj tylko raz
\&    }
.Ve
.Vb 1
\&    if (($F1, $F2, $Etc) = ($foo =~ /^(\eS+)\es+(\eS+)\es*(.*)/))
.Ve
Ostatni przyk³ad dzieli \f(CW$foo\fR na pierwsze dwa s³owa i resztê linii.
Przypisuje te trzy pola do \f(CW$F1\fR, \f(CW$F2\fR i \f(CW$Etc\fR.  
Warunek jest prawdziwy, je¶li przypisane zosta³y warto¶ci którejkolwiek ze
zmiennych, czyli je¶li wzorzec zosta³ trafiony.
.Sp
Modyfikator \f(CW/g\fR okre¶la globalne porównywanie wzorców \*(-- tj. takie,
gdzie trafieñ jest tyle ile siê da w danym ³añcuchu. Zachowanie tego zale¿y
od kontektu -- w listowym zwracana jest lista wszystkich pod³añcuchów,
trafionych przez wszystkie nawaisy wyra¿enia regularnego.
Je¶li nie by³o nawiasów, zwracana jest lista trafionych ³añcuchów, tak jakby
by³y nawiasy wokó³ ca³ego wzorca.
.Sp
W kontek¶cie skalarnym, \f(CW,//g\fR iteruje poprzez ³añcuch, zwracaj±c
\s-1TRUE\s0 za ka¿dym trafieniem i \s-1FALSE\s0 przy braku trafienia.
(Innymi s³owy, zapamiêtuje ostatni± pozycjê i restartuje od tego miejsca.
Mo¿esz znale¼æ bie¿±c± pozycjê trafienia przy u¿yciu funkcji \fIpos()\fR;
zobacz jej opis w podrêczniku \fIperlfunc\fR(1).)
Brak trafienia normalnie resetuje pozycjê przeszukiwania na pocz±tek
³añcucha, lecz mo¿esz temu zapobiec, dodaj±c modyfikator \*(L"c\*(R"
(np. \f(CWm//gc\fR).  Modyfikowanie ³añcucha docelowego równie¿ resetuje
pozycjê przeszukiwania.
.Sp
Mo¿esz mieszaæ porównania \f(CWm//g\fR z \f(CWm/\eG.../g\fR, 
gdzie \f(CW\eG\fR jest zapewnieniem zerowej szeroko¶ci, które trafia w
dok³adnie tê sam± pozycjê, gdzie skoñczy³ ewentualny poprzedni
\f(CWm//g\fR.
Zapewnienie \f(CW\eG\fR nie jest obs³ugiwane bez modyfikatora \f(CW/g\fR;
obecnie bez \f(CW/g\fR, \f(CW\eG\fR, zachowuje siê zupe³nie jak
\f(CW\eA\fR, lecz jest to przypadkowe i mo¿e siê w przysz³o¶ci zmieniæ.
.Sp
Przyk³ady:
.Sp
.Vb 2
\&    # kontekst listowy
\&    ($one,$five,$fifteen) = (`uptime` =~ /(\ed+\e.\ed+)/g);
.Ve
.Vb 8
\&    # kontekst skalarny
\&    $/ = ""; $* = 1;  # $*, niezalecany w nowoczesnych perlach
\&    while (defined($paragraph = <>)) {
\&        while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\es/g) {
\&            $sentences++;
\&        }
\&    }
\&    print "$sentences\en";
.Ve
.Vb 10
\&    # u¿ywanie m//gc z \eG
\&    $_ = "ppooqppqq";
\&    while ($i++ < 2) {
\&        print "1: '";
\&        print $1 while /(o)/gc; print "', pos=", pos, "\en";
\&        print "2: '";
\&        print $1 if /\eG(q)/gc;  print "', pos=", pos, "\en";
\&        print "3: '";
\&        print $1 while /(p)/gc; print "', pos=", pos, "\en";
\&    }
.Ve
Ostatni przyk³ad powinien daæ:
.Sp
.Vb 6
\&    1: 'oo', pos=4
\&    2: 'q', pos=5
\&    3: 'pp', pos=7
\&    1: '', pos=7
\&    2: 'q', pos=8
\&    3: '', pos=8
.Ve
Przydatnym idiomem dla skanerów w rodzaju \f(CWlex\fR jest
\f(CW/\eG.../gc\fR. Mo¿esz tak ³±czyæ ró¿ne rodzaje wyra¿eñ regularnych,
maj±c tak mo¿liwo¶æ przetwarzania ³añcucha kawa³ek po kawa³ku, dokonuj±c
ró¿nych akcji, zale¿nie od tego, które wyra¿enie zosta³o trafione. Ka¿de
wyra¿enie próbuje trafiæ tam, gdzie poprzednie zakoñczy³o.
.Sp
.Vb 14
\& $_ = <<'EOL';
\&      $url = new URI::URL "http://www/";   die if $url eq "xXx";
\& EOL
\& LOOP:
\&    {
\&      print(" digits"),         redo LOOP if /\eG\ed+\eb[,.;]?\es*/gc;
\&      print(" lowercase"),      redo LOOP if /\eG[a-z]+\eb[,.;]?\es*/gc;
\&      print(" UPPERCASE"),      redo LOOP if /\eG[A-Z]+\eb[,.;]?\es*/gc;
\&      print(" Capitalized"),    redo LOOP if /\eG[A-Z][a-z]+\eb[,.;]?\es*/gc;
\&      print(" MiXeD"),          redo LOOP if /\eG[A-Za-z]+\eb[,.;]?\es*/gc;
\&      print(" alphanumeric"),   redo LOOP if /\eG[A-Za-z0-9]+\eb[,.;]?\es*/gc;
\&      print(" line-noise"),     redo LOOP if /\eG[^A-Za-z0-9]+/gc;
\&      print ". That's all!\en";
\&    }
.Ve
Oto wyj¶cie (podzielone na kilka linii):
.Sp
.Vb 4
\& line-noise lowercase line-noise lowercase UPPERCASE line-noise
\& UPPERCASE line-noise lowercase line-noise lowercase line-noise
\& lowercase lowercase line-noise lowercase lowercase line-noise
\& MiXeD line-noise. That's all!
.Ve
.Ip "q/\s-1£AÑCUCH\s0/" 8
.IX Item "q/\s-1£AÑCUCH\s0/"
.Ip "\f(CW'£AÑCUCH'\fR" 8
.IX Item "\f(CW'£AÑCUCH'\fR"
Pojedynczo zacytowany ³añcuch literalny. Odwrotny uko¶nik oznacza odwrotny
uko¶nik, chyba
¿e znajduje siê za nim ogranicznik lub inny odwrotny uko¶nik -- w tym wypadku
odwrotny uko¶nik, lub ogranicznik jest interpolowany.
.Sp
.Vb 3
\&    $foo = q!I said, "You said, 'She said it.'"!;
\&    $bar = q('This is it.');
\&    $baz = '\en';                # ³añcuch dwuznakowy
.Ve
.Ip "qq/\s-1£AÑCUCH\s0/" 8
.IX Item "qq/\s-1£AÑCUCH\s0/"
.Ip "\*(N"\s-1£AÑCUCH\s0\*(T"" 8
.IX Item "\*(N"\s-1£AÑCUCH\s0\*(T""
£añcuch w podwójnych cudzys³owach, interpolowany.
.Sp
.Vb 4
\&    $_ .= qq
\&     (*** The previous line contains the naughty word "$1".\en)
\&                if /(tcl|rexx|python)/;      # :-)
\&    $baz = "\en";                # ³añcuch jednoznakowy
.Ve
.Ip "qx/\s-1£AÑCUCH\s0/" 8
.IX Item "qx/\s-1£AÑCUCH\s0/"
.Ip "`\s-1£AÑCUCH\s0`" 8
.IX Item "`\s-1£AÑCUCH\s0`"
£añcuch, który jest interpolowany, a nastêpnie uruchamainay jako komenda
systemowa. Zebrane standardowe wyj¶cie komendy jest zwracane. W kontek¶cie
skalarnym, pojawia siê jako pojedynczy, wieloliniowy ³añcuch.
W kontek¶cie listowym, jest rozdzielony na listê linii (jakkolwiek
zdefiniowa³e¶ linie $/ lub \f(CW$INPUT_RECORD_SEPARATOR\fR).
.Sp
.Vb 1
\&    $today = qx{ date };
.Ve
Zobacz sekcjê o operatorach I/O.
.Ip "qw/\s-1£AÑCUCH\s0/" 8
.IX Item "qw/\s-1£AÑCUCH\s0/"
Zwraca listê s³ów, wyci±gniêtych z ³añcucha przy u¿yciu osadzonych bia³ych
spacji, jako ograniczników s³ów. Jest to równowa¿ne
.Sp
.Vb 1
\&    split(' ', q/£AÑCUCH/);
.Ve
Pewne czêsto u¿ywane przyk³ady:
.Sp
.Vb 2
\&    use POSIX qw( setlocale localeconv )
\&    @EXPORT = qw( foo bar baz );
.Ve
Czêstym b³êdem jest próba rozdzielania s³ów przecinkiem, lub wstwianie do
wieloliniowych ³añcuchów qw komentarzy. W tej sytuacji, prze³±cznik
\f(CW-w\fR daje ostrze¿enia je¶li ³añcuch zawiera znaki \*(L"#\*(R".
.Ip "s/\s-1WZORZEC/ZAMIANA/\s0egimosx" 8
.IX Item "s/\s-1PATTERN/REPLACEMENT/\s0egimosx"
Szuka w ³añcuchu wzorca, a je¶li go znajdzie, to zamienia go tekstem zamiany
i zwraca liczbê zamian. W przeciwnym wypadku zwraca fa³sz (specyficznie
pusty ³añcuch).
.Sp
Je¶li przez operator \f(CW=~\fR lub \f(CW!~\fR nie podano ³añcucha, u¿ywana
jest zmienna \f(CW$_\fR. (£añcuch podany przez \f(CW=~\fR musi
byæ zmienn± skalarn±, elementem tablicy, tablicy asocjacyjnej, lub 
przypisaniem do jednego z nich, czyli lwarto¶ci±.)
.Sp
Je¶li wybrany ogranicznik jest pojedynczym cudzys³owem, nie dokonywana jest
interpolacja ani zmiennych \s-1WZORCA\s0, ani \s-1ZAMIANY\s0. W przeciwnym
wypadku, je¶li
\s-1WZORZEC\s0 zawiera $, który wygl±da bardziej jak zmienna, ni¿ test koñca
³añcucha, zmienna bêdzie interpolowana w czasie dzia³ania.
Je¶li chcesz, by wzorzec by³ kompilowany tylko raz, za pierwsz± interpolacj±
zmiennej, u¿yj opcji \f(CW/o\fR. Je¶li wzorzec jest analizowany jako ³añcuch
null, uzywane jest zamiast tego ostatnie normalne wyra¿enie regularne.
Zobacz jeszcze podrêcznik \fIperlre\fR(1).
Zobacz te¿ \fIperllocale\fR(1), aby dowiedzieæ siê o wp³ywie \f(CWuse
locale\fR.
.Sp
Opcje to:
.Sp
.Vb 7
\&    e   Analizuj praw± stronê jako wyra¿enie
\&    g   Zamieniaj globalnie
\&    i   Nie zwracaj uwagi na wielko¶æ liter
\&    m   Traktuj ³añcuch jak wiele linii
\&    o   Kompiluj wzorzec tylko raz
\&    s   Traktuj ³añcuch jako pojedyncz± liniê
\&    x   U¿yj rozszerzonych wyra¿eñ regularnych
.Ve
Uko¶niki mog± byæ zamienione przez dowolny, niealfanumeryczny i
niebia³ospacjowy ogranicznik. Je¶li u¿yte s± pojedyncze cudzys³owy, nie
dokonywana jest interpretacja ³añcucha zamiany (modyfikator \f(CW/e\fR
przeci±¿a to zachowanie). W przeciwnieñstwie do perla 4, perl 5 traktuje
odwrotne cudzys³owy jako normalne ograniczniki; tekst zamiany nie jest 
wykonywany jako komenda.
Je¶li \s-1WZORZEC\s0 jest rozdzielany cytatami nawiasowymi, \s-1ZAMIANA\s0
ma swoj± w³asn± parê cytatów, która mo¿e, lub nie, byæ cytatami nawiasowymi, np.
\f(CWs(foo)(bar)\fR lub \f(CWs<foo>/bar/\fR.  \f(CW/e\fR spowoduje, ¿e
porcja zamiany zostanie zinterpretowana jako pe³ne perlowe wyra¿enie i
z\fIeval()\fRowana zaraz potem. Jego sk³adnia jest jednak sprawdzania
podczas kompilacji.
.Sp
Przyk³ady:
.Sp
.Vb 1
\&    s/\ebgreen\eb/mauve/g;                # nie zmieniaj wintergreen
.Ve
.Vb 1
\&    $path =~ s|/usr/bin|/usr/local/bin|;
.Ve
.Vb 1
\&    s/Login: $foo/Login: $bar/; # wzorzec czasu dzia³ania
.Ve
.Vb 1
\&    ($foo = $bar) =~ s/this/that/;
.Ve
.Vb 1
\&    $count = ($paragraph =~ s/Mister\eb/Mr./g);
.Ve
.Vb 4
\&    $_ = 'abc123xyz';
\&    s/\ed+/$&*2/e;               # daje 'abc246xyz'
\&    s/\ed+/sprintf("%5d",$&)/e;  # daje 'abc  246xyz'
\&    s/\ew/$& x 2/eg;             # daje 'aabbcc  224466xxyyzz'
.Ve
.Vb 3
\&    s/%(.)/$percent{$1}/g;      # zmieñ eskejpy procentowe; bez /e
\&    s/%(.)/$percent{$1} || $&/ge;       # teraz z wyra¿enim, z /e
\&    s/^=(\ew+)/&pod($1)/ge;      # u¿yj wywo³ania funkcji
.Ve
.Vb 3
\&    # /e mog± siê zagnie¿d¿aæ; to rozwinie
\&    # proste zmienne osadzone w $_
\&    s/(\e$\ew+)/$1/eeg;
.Ve
.Vb 6
\&    # Usuñ komentarze C
\&    $program =~ s {
\&        /\e*     # Traf na rozdzielacz otwieraj±cy.
\&        .*?     # Traf w minimaln± liczbê znaków.
\&        \e*/     # Traf w rozdzielacz zamykaj±cy.
\&    } []gsx;
.Ve
.Vb 1
\&    s/^\es*(.*?)\es*$/$1/;        # odetnij bia³± spacjê
.Ve
.Vb 1
\&    s/([^ ]*) *([^ ]*)/$2 $1/;  # zamieñ 1-sze 2 pola
.Ve
Zauwa¿, ¿e w ostatnim przyk³adzie zamiast $ u¿yto \e. W przeciwieñstwie do
\fBsed\fR(1)a, u¿ywamy postaci \e<\fIcyfra\fR> tylko po lewej stronie.
Wszêdzie indziej, jest to $<\fIcyfra\fR>.
.Sp
Czasami nie mo¿na u¿yæ po prostu \f(CW/g\fR, aby zasz³y wszystkie zmiany.
Oto dwa popularne przypadki:
.Sp
.Vb 3
\&    # wstaw przecinki we w³a¶ciwych miejscach integera
\&    1 while s/(.*\ed)(\ed\ed\ed)/$1,$2/g;      # perl4
\&    1 while s/(\ed)(\ed\ed\ed)(?!\ed)/$1,$2/g;  # perl5
.Ve
.Vb 2
\&    # rozwiñ tabulacje na 8-kolumnowe spacje
\&    1 while s/\et+/' ' x (length($&)*8 - length($`)%8)/e;
.Ve
.Ip "tr/\s-1LISTASZUKANIA/LISTAZAMIANY/\s0cds" 8
.IX Item "tr/\s-1SEARCHLIST/REPLACEMENTLIST/\s0cds"
.Ip "y/\s-1LISTASZUKANIA/LISTAZAMIANY/\s0cds"
.IX Item "y/\s-1SEARCHLIST/REPLACEMENTLIST/\s0cds" 8
T³umaczy wszystkie pojawienia siê znaków, znalezione w li¶cie szukania, na
odpowiadaj±ce znaki z listy zamiany. Zwraca liczbê zamienionych, lub
skasowanych znaków. Je¶li nie podano ³añcucha w operatorze =~ lub !~, u¿ywane
jest \f(CW$_\fR. (£añcuch okre¶lony przez =~ musi byæ zmienn± skalarn±,
elementem tablicy, elementem tablicy asocjacyjnej, lub przypisaniem do
jednego z nich, czyli lwarto¶ci±).
Dla mi³o¶ników edytora \fBsed\fR(1), udostêpniono synonim \f(CWtr\fR pod
nazw± \f(CWy\fR. Je¶li \s-1LISTASZUKANIA\s0 jest rozdzielona
nawiasami, to \s-1LISTAZAMIANY\s0 nie musi ich mieæ, np.
\f(CWtr[A-Z][a-z]\fR lub \f(CWtr(+-*/)/ABCD/\fR.
.Sp
Opcje:
.Sp
.Vb 3
\&    c   Dope³nij LISTÊSZUKANIA
\&    d   Kasuj znalezione, lecz niezamienione znaki
\&    s   Zmia¿d¿ zduplikowane zamienione znaki
.Ve
Je¶li podany jest modyfikator \f(CW/c\fR, zbiór znaków z
\s-1LISTYSZUKANIA\s0 jest dope³niany. Je¶li podany jest modyfikator
\f(CW/d\fR, wszelkie znaki, podane w \s-1LI¦CIESZUKANIA\s0, a nie znalezione
w \s-1LI¦CIEZAMIANY\s0 s± kasowane.
Je¶li podany jest modyfikator \f(CW/s\fR, to sekwencje, które zosta³y
przet³umaczone do tego samego znaku s± mia¿d¿one do pojedynczej instancji
tego znaku.
.Sp
Je¶li u¿yty jest modyfikator \f(CW/d\fR, \s-1LISTAZAMIANY\s0 jest zawsze
interpretowana tak, jak jest podana. W przeciwnym wypadku, gdy
\s-1LISTAZAMIANY\s0 jest krótsza ni¿ \s-1LISTASZUKANIA\s0, ostatni jej znak 
jest replikowany tak d³ugo, a¿ wype³ni brakuj±ce miejsca. Je¶li
\s-1LISTAZAMIANY\s0 jest null, to replikowana jest \s-1LISTASZUKANIA\s0.
Jest to przydatne do zliczania znaków w klasie, lub dla mia¿d¿enia sekwencji
znakowych klasy.
.Sp
Przyk³ady:
.Sp
.Vb 1
\&    $ARGV[1] =~ tr/A-Z/a-z/;    # zmieñ na ma³e litery
.Ve
.Vb 1
\&    $cnt = tr/*/*/;             # zlicz gwiazdy w $_
.Ve
.Vb 1
\&    $cnt = $sky =~ tr/*/*/;     # zlicz gniazdy w $sky
.Ve
.Vb 1
\&    $cnt = tr/0-9//;            # zlicz cyfry w $_
.Ve
.Vb 1
\&    tr/a-zA-Z//s;               # bookkeeper -> bokeper
.Ve
.Vb 1
\&    ($HOST = $host) =~ tr/a-z/A-Z/;
.Ve
.Vb 1
\&    tr/a-zA-Z/ /cs;             # zmieñ niealfabetyczne na spacje
.Ve
.Vb 2
\&    tr [\e200-\e377]
\&       [\e000-\e177];             # skasuj 8-my bit
.Ve
Je¶li dla znaku podano wiele translacji, u¿ywana jest tylko pierwsza:
.Sp
.Vb 1
\&    tr/AAA/XYZ/
.Ve
przet³umaczy A na X.
.Sp
Zauwa¿, ¿e z uwagi na to, ¿e tablica translacji jest budowana w czasie
kompilacji, ani \s-1LISTASZUKANIA\s0, ani \s-1LISTAZAMIANY\s0 nie podlegaj±
interpolacji cudzys³owowej. Znaczy to, ¿e je¶li chcesz u¿ywaæ zmiennych,
musisz u¿yæ \fIeval()\fR:
.Sp
.Vb 2
\&    eval "tr/$oldlist/$newlist/";
\&    die $@ if $@;
.Ve
.Vb 1
\&    eval "tr/$oldlist/$newlist/, 1" or die $@;
.Ve
.Sh "Operatory I/O"
.IX Subsection "I/O Operators"
Istnieje wiele operatorów I/O (wej¶cia/wyj¶cia), o których powiniene¶
wiedzieæ.
£añcuch ujêty w odwrotne cudzys³owy podlega najpierw podstawieniu zmiennych,
podobnie jak ³añcuch ujêty w podwójne cudzys³owy. Nastêpnie jest
interpretowany jako komenda, a jej wyj¶cie jest warto¶ci± pseudolitera³u,
jak w pow³oce. W kontek¶cie skalarnym, zwracany jest pojedynczy ³añcuch,
sk³±daj±cy siê z ca³ego wyj¶cia. W kontek¶cie listowym, zwracana jest lista
warto¶ci dla ka¿dej linii wyj¶cia. (Mo¿na ustawiæ \f(CW$/\fR, co przeci±¿y
domy¶lny terminator linii.)
Komenda jest wykonywana przy ka¿dej analizie pseudolitera³u. Status komendy
jest zwracany do \f(CW$?\fR (zobacz podrêcznik \fIperlvar\fR(1)).
W przeciwieñstwie do \fBcsh\fR(1), nie jest na danych
zwracanych dokonywana translacja \*-- nowe linie pozostaj± nowymi liniami. W
przeciwieñstwie do wszelkich innych pow³ok, pojedyncze cudzys³owyu nie
ukrywaj± nazw zmiennych w komendzie od interpretacji. Aby przekazaæ $ dalej,
nale¿y go wycytowaæ odwrotnym uko¶nikiem.
Ogóln± postaci± odwrotnych cudzys³owów jest \f(CWqx//\fR. (Poniewa¿ podlegaj±
one zawsze równie¿ rozwiniêciu przez pow³okê, zobacz podrêcznik
\fIperlsec\fR(1), który opisuje problemy bezpieczeñstwa.)
.PP
Analiza uchwytu pliku, który jest w nawiasach trójk±tnych, wyci±ga z pliku
nastêpn± liniê, lub \f(CWundef\fR na jego koñcu.
Normalnie, musisz zmiennej przypisaæ warto¶æ, lecz jest sytuacja, w której
nastêpuje automatyczne przypisanie. \fIJe¶li i \s-1TYLKO\s0 je¶li\fR symbol
wej¶cia jest jedyn± rzecz± wewn±trz warunku pêtli \f(CWwhile\fR lub
\f(CWfor(;;)\fR, to warto¶æ jest przypisywana automatycznie zmiennej
\f(CW$_\fR. Przypisana warto¶æ jest potem sprawdzana, by zobaczyæ czy jest
zdefiniowane (Mo¿e siê to wydawaæ trochê dziwne, lecz bêdziesz u¿ywaæ tej
konstrukcji w prawie ka¿dym swoim skrypcie perlowym.) Nastêpuj±ce linijki s±
sobie równowa¿ne:
.PP
.Vb 5
\&    while (defined($_ = <STDIN>)) { print; }
\&    while (<STDIN>) { print; }
\&    for (;<STDIN>;) { print; }
\&    print while defined($_ = <STDIN>);
\&    print while <STDIN>;
.Ve
Uchwyty plików \s-1STDIN\s0, \s-1STDOUT\s0 i \s-1STDERR\s0 to uchwyty
predefiniowane. Uchwyty \f(CWstdin\fR, \f(CWstdout\fR i
\f(CWstderr\fR te¿ bêd± dzia³aæ, lecz nie w pakietach, w których s±
interpretowane jako lokalne identyfikatory nie za¶ jako globalne.)
Dodatkowe uchwyty plików mo¿na tworzyæ funkcj± \fIopen()\fR. Zobacz jej opis
w podrêczniku \fIperlfunc\fR(1).
.PP
Je¶li <\s-1UCHWYTPLIKU\s0 jest u¿ywany w kontek¶cie, oczekuj±cym listy,
zwracana jest lista, sk³adaj±ca siê ze wszystkich linii wej¶ciowych, jedna
linia na element listy. £atwo jest zaj±æ tak du¿y obszar danych, wiêc u¿ywaj
tego ostro¿nie.
.PP
Zerowy uchwyt pliku <> jest specjalny i mo¿e byæ u¿ywany do emulacji
zachowania edytora \fBsed\fR(1), lub \fBawk\fR(1). Wej¶cie z <> mo¿e
nadchodziæ zarówno ze standardowego wej¶cia, lub z ka¿dego pliku,
wymienionego w linii komend. Oto jak to dzia³a: za pierwsz± analiz± <>,
sprawdzana jest tablica \f(CW@ARGV\fR i je¶li jest zerowa,
\f(CW$ARGV[0]\fR jest ustawiane na \*(L"\-\*(R", co oznacza po otwarciu 
standardowe wej¶cie. Tablica \f(CW@ARGV\fR jest nastêpnie przetwarzana jako
lista nazw plików.
Pêtla
.PP
.Vb 3
\&    while (<>) {
\&        ...                     # kod dla ka¿dej linii
\&    }
.Ve
jest równowa¿na nastêpuj±cemu pseudokodowi:
.PP
.Vb 7
\&    unshift(@ARGV, '-') unless @ARGV;
\&    while ($ARGV = shift) {
\&        open(ARGV, $ARGV);
\&        while (<ARGV>) {
\&            ...         # kod dla ka¿dej linii
\&        }
\&    }
.Ve
poza tym, ¿e jest trochê ³adniejsza i dzia³a. Naprawdê przesuwa tablicê
\f(CW@ARGV\fR i wstawia bie¿±c± nazwê pliku do zmiennej \f(CW$ARGV\fR.
U¿ywa te¿ wewnêtrznie uchwytu \fI\s-1ARGV\s0\fR--<> jest po prostu synonimem
<\s-1ARGV\s0>, który jest magiczny. (Powy¿szy pseudokod nie dzia³a, gdy¿
traktuje \s-1ARGV\s0 amagicznie.)
.PP
Przed pierwszym <> mo¿esz modyfikowaæ \f(CW@ARGV\fR, o ile tablica bêdzie
zawiera³a listê plików, których oczekujesz. Numey linii (\f(CW$.\fR) s±
liczone tak, jakby wej¶cie by³o tylko jednym, szczê¶liwym plikiem. (Lecz
zobacz przyk³ad z \fIeof()\fR, aby zobaczyæ jak zresetowaæ numery linii.)
.PP
Je¶li chcesz ustawiæ \f(CW@ARGC\fR na swoj± w³asn± listê plików, to nie ma
sprawy. Je¶li chcesz przekazaæ do swojego skryptu prze³±czniki, mo¿esz u¿yæ
jednego z modu³ów Getopts, lub wstawiæ na pocz±tku podobn± pêtlê:
.PP
.Vb 10
\&    while ($_ = $ARGV[0], /^-/) {
\&        shift;
\&        last if /^--$/;
\&        if (/^-D(.*)/) { $debug = $1 }
\&        if (/^-v/)     { $verbose++  }
\&        ...             # inne prze³±czniki
\&    }
\&    while (<>) {
\&        ...             # kod dla ka¿dej linii
\&    }
.Ve
Symbol <> zwraca \s-1FALSE\s0 tylko raz. Jesli wywo³asz go po tym, za³o¿y,
¿e przetwarzasz now± listê \f(CW@ARGV\fR i je¶li jej nie ustawi³e¶, pobierze
wej¶cie ze \s-1STDIN\s0.
.PP
Je¶li ³añcuch wewn±trz nawiasów trójk±tnych jest wskazaniem do zmiennej 
skalarnej (np. <$foo>), to zmienna ta przechowuje nazwê uchwytu, z którego
pobierane jest wej¶cie. Np:
.PP
.Vb 2
\&    $fh = \e*STDIN;
\&    $line = <$fh>;
.Ve
£añcuch w nawiasach trójk±tnych nie jest uchwytem pliku, to jest
interpretowany jako wzorzec nazwy pliku do glob()owania i zwracana jest albo
lista nazw pliku lub nastêpna nazwa pliku (zale¿nie od kontekstu).
Najpierw dokonywany jest jeden poziom interpretacji $, lecz nie mo¿na
powiedzieæ \f(CW<$foo>\fR, gdy¿ jest to niebezpo¶redni uchwyt pliku,
opisany w poprzednim paragrafie. (W starszych wersjach perla, programi¶ci
mogli wstawiaæ nawiasy do wymuszania interpretacji jako nazwy pliku do
globowania: \f(CW<${foo}>\fR. Dzi¶ jednak, za czystsze uwa¿a siê
bezpo¶rednie wo³anie funkcji wewnêtrznej -- \f(CWglob($foo)\fR. Przyk³ad:
.PP
.Vb 3
\&    while (<*.c>) {
\&        chmod 0644, $_;
\&    }
.Ve
jest równowa¿ny
.PP
.Vb 5
\&    open(FOO, "echo *.c | tr -s ' \et\er\ef' '\e\e012\e\e012\e\e012\e\e012'|");
\&    while (<FOO>) {
\&        chop;
\&        chmod 0644, $_;
\&    }
.Ve
W rzeczywisto¶ci, obecnie jest to w³a¶nie tak zaimplementowane. (Co znaczy,
¿e nie bêdzie dzia³aæ na nazwach plików ze spacjami, chyba ¿e masz u siebie
\fIcsh\fR(1).) Oczywi¶cie najkrótszym sposobem dokonania powy¿szego jest:
.PP
.Vb 1
\&    chmod 0644, <*.c>;
.Ve
Poniewa¿ globowanie u¿ywa pow³oki, czêsto szybciej jest wywo³aæ samodzielnie
\fIreaddir()\fR i dokonaæ \fIgrep()\fRa na nazwach plików. Co wiêcej, z
powodu obecnej implementacji, wywo³anie \fIglob()\fR mo¿e
napotkaæ b³êdy w rodzaju \*(L"Arg list too
long\*(R" (chyba ¿e zainstalowa³e¶ \fItcsh\fR\|(1L) jako \fI/bin/csh\fR).
.PP
Glob analizuje swój (osadzony) argument tylko je¶li rozpoczyna now± listê.
Wszystkie warto¶ci musz± byæ odczytane zanim znów rozpocznie. W kontek¶cie
listowym nie jest to istotne, gdy¿ autmatycznie odczytujesz wszystkie.
Jednak w kontek¶cie skalarnym, operator zwraca nastêpn± warto¶æ za ka¿dym
wywo³aniem, lub \s-1FALSE\s0 na koñcu. Znowu, \s-1FALSE\s0 jest zwracane
tylko raz. Je¶li wiêc oczekujesz od globa pojedynczej warto¶ci, to lepiej
powiedzieæ
.PP
.Vb 1
\&    ($file) = <blurch*>;
.Ve
a nie
.PP
.Vb 1
\&    $file = <blurch*>;
.Ve
gdy¿ to drugie bêdzie rozró¿niaæ zwrócenie nazwy plików i zwrócenie
\s-1FALSE\s0.
.PP
Je¶li próbujesz dokonaæ interpolacji zmiennych, to zdecydowanie lepiej jest
u¿yæ funkcji \fIglob()\fR, gdy¿ starsza notacja mo¿e spowodowaæ zak³opotanie
u niektórych osób.
.PP
.Vb 2
\&    @files = glob("$dir/*.[ch]");
\&    @files = glob($files[$i]);
.Ve
.Sh "Zawijanie sta³ych"
.IX Subsection "Constant Folding"
Podobnie jak C, perl posiada pewien zestaw analiz wyra¿eñ, wykonywanych
podczas kompilacji -- dzieje siê to je¶li zauwa¿y, ¿e wszystkie argumenty
operatora  s± statyczne i nie maj± efektów ubocznych. W szczególno¶ci, np.
konkatenacja litera³ów bez podstawieñ zmiennych jest dokonywana podczas 
kompilacji. Interpretacja odwrotnych uko¶ników nastêpuje równie¿ podczas 
kompilacji. Mo¿esz powiedzieæ
.PP
.Vb 2
\&    'Now is the time for all' . "\en" .
\&        'good men to come to.'
.Ve
a wszystko to wewnêtrznie zredukuje siê do jednego ³añcucha. Podobnie, je¶li
powiesz
.PP
.Vb 3
\&    foreach $file (@filenames) {
\&        if (-s $file > 5 + 100 * 2**16) { ... }
\&    }
.Ve
to kompilator przeliczy liczby, które reprezentuje wyra¿enie.
.Sh "Arytmetyka ca³kowita"
.IX Subsection "Integer Arithmetic"
Domy¶lnie, perl wykonuje wszystkie obliczenia zmiennoprzecinkowo. Jednak
powiedzenie
.PP
.Vb 1
\&    use integer;
.Ve
mówi kompilatorowi, ¿e mo¿e u¿ywaæ odt±d, do koñca bloku operacji
ca³kowitych. Wewnêtrzne bloki mog± temu zaprzeczyæ, mówi±c
.PP
.Vb 1
\&    no integer;
.Ve
co wystarcza do koñca ich bloku.
.PP
Operatory bitowe ("&\*(R", \*(L"|\*(R", \*(L"^\*(R", \*(L"~\*(R", \*(L"<<\*(R",
i \*(L">>") zawsze daj± wyniki ca³kowite. Jednak \f(CWuse integer\fR ma
wci±¿ dla nich znaczenie. Domy¶lnie ich wyniki s± interpretowane jako liczby
ca³kowite bez znaku. Po w³±czeniu tej opcji, sa interpretowane ze znakiem.
Np. \f(CW~0\fR normalnie jest analizowane do wielkiej warto¶ci ca³kowitej.
Po \f(CWuse integer; ~0\fR staje siê \-1.
.Sh "Arytmetyka zmiennoprzecinkowa"
.IX Subsection "Floating-point Arithmetic"
Podczas gdy \f(CWuse integer\fR daje arytmetykê ca³kowit±, nie ma podobnej
instrukcji dla dawania zaokr±gleñ, lub odciêæ w konkretnych miejscach
dziesiêtnych. Dla zaokr±gleñ do okre¶lonej ilo¶ci cyfr, najlepiej u¿yæ
\fIsprintf()\fR lub \fIprintf()\fR.
.PP
Modu³ \s-1POSIX\s0 (czê¶æ standardowej dystrybucji perla) 
implementuje funkcje \fIceil()\fR, \fIfloor()\fR i kilka
innych funkcji matematycznych i trygonometrycznych. Modu³ Math::Complex
(równie¿ standardowy) definiuje sporo funkcji matematycznych, które mog±
dzia³aæ równie¿ na liczbach rzeczywistych. Modu³ Math::Complex nie jest tak
wydajny jak \s-1POSIX\s0, lecz \s-1POSIX\s0 nie mo¿e dzia³aæ na liczbach
zespolonych.
.PP
Zaokr±glanie w aplikacjach finansowych mo¿e mieæ powa¿ne konsekwencje i
u¿ywana metoda powinna byæ podawana dok³adnie. W tych wypadkach, lepiej nie
ufaæ temu, który system zaokr±glania jest u¿ywany przez perla, lecz
zaimplementowaæ tak± funkcjê samodzielnie.

.rn }` ''
