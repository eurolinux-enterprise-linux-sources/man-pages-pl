.\" $Id: lisp-tut.5,v 1.6 2003/05/29 11:06:07 robert Exp $
.TH LISP-TUT 5 "wrzesieñ 1999"
.SH NAZWA
lisp-tut - Wskazówki dla Common LISP
.SH OPIS

Uwaga: to wprowadzenie do Common Lisp zosta³o napisane dla ¶rodowiska CMU,
wiêc niektóre fragmenty pracy z lispem mog± siê trochê ró¿niæ w ró¿nych 
miejscach.

.SH Inne ¼ród³a informacji

Najlepsza ksi±¿ka o LISP, któr± znam, to

.B Guy L. Steele Jr. _Common LISP: the Language_. Digital Press. 1984.

Pierwsza edycja jest ³atwiejsza do czytania; druga opisuje trochê nowszy
standard. (Ró¿nice miêdzy standardami nie powinny sprawiaæ ró¿nic zwyk³ym
programistom).

Polecano mi równie¿ ksi±¿kê \fBDave'a Touretsky'ego\fR, choæ nie czyta³em
jej i nie mogê o niej nic powiedzieæ.

.SH Symbole

Symbol to ³añcuch znaków. Istniej± ograniczenia co do tego, co mo¿na wstawiæ
do symbolu i co mo¿e byæ pierwszym znakiem, lecz tak d³ugo jak u¿ywasz
prostych liter, cyfr i my¶lników, nic siê nie stanie.
(Poza tym, ¿e je¶li u¿ywasz tylko cyfr i prawdopodobnie pocz±tkowego
my¶lnika, to LISP mo¿e pomy¶leæ, ¿e to liczba ca³kowita, a nie symbol.)
Przyk³ady symboli:
.nf
.sp
        a
        b
        c1
        foo
        bar
        baaz-quux-garply
.fi

Dalej przedstawiamy kilka rzeczy, które mo¿na zrobiæ z symbolami. (Rzeczy po
znaku zachêty "\fB>\fR" s± tym, co nale¿y wstukaæ do interpretera LISP, 
podczas gdy inne rzeczy s± odpowiedziami, drukowanymi przez LISP. Znak "\fB;\fR" 
jest LISP-owym znakiem komentarza: wszystko od ";" do koñca linii jest
ignorowane.
.nf
.sp
> (setq a 5)         ;zachowaj liczbê jako warto¶æ symbolu
5
> a                  ;pobierz warto¶æ symbolu
5
> (let ((a 6)) a)    ;przywi±¿ tymczasowo warto¶æ symbolu do 6
6
> a                  ;po zakoñczeniu let, warto¶æ wraca do 5
5
> (+ a 6)            ;u¿yj warto¶ci symbolu jako argumentu funkcji
11
> b                  ;spróbuj pobraæ warto¶æ symbolu, który nie ma warto¶ci
Error: Attempt to take the value of the unbound symbol B
.fi

Istniej± dwa symbole specjalne, `\fBt\fR' i `\fBnil\fR'. Warto¶æ `\fBt\fR' jest
zdefiniowana zawsze jako `\fBt\fR', a warto¶æ `\fBnil\fR' jest zdefiniowana
zawsze jako `\fBnil\fR'. LISP u¿ywa `t' i `nil' do reprezentowania prawdy i 
fa³szu. Przyk³adowe u¿ycie, opisane dok³adniej dalej:
.nf
.sp
> (if t 5 6)
5
> (if nil 5 6)
6
> (if 4 5 6)
5
.fi

Ostatni przyk³ad jest cudaczny, lecz prawid³owy: `nil' oznacza fa³sz, a
wszystko inne oznacza prawdê. (O ile nie mamy potrzeby robiæ inaczej,
u¿ywamy t do oznaczania prawdy, tak dla czystej prostoty.)

Symbole takie jak `t' i `nil' s± nazywane samorozwijaj±cymi, poniewa¿ rozwijaj±
siê same na siebie. Istnieje ca³a klasa samorozwijaj±cych siê symboli,
zwanych s³owami kluczowymi; dowolny symbol, którego nazwa rozpoczyna siê od
dwukropka jest s³owem kluczowym. (Zobacz ni¿ej przyk³ady zastosowañ s³ów
kluczowych.) Przyk³ady:
.nf
.sp
> :this-is-a-keyword
:THIS-IS-A-KEYWORD
> :so-is-this
:SO-IS-THIS
> :me-too
:ME-TOO
.fi

.SH Liczby

.B Liczba ca³kowita 
jest ³añcuchem cyfr, opcjonalnie poprzedzonych + lub -.
.B Liczba rzeczywista 
wygl±da jak liczba ca³kowita, lecz ma kropkê dziesiêtn± i
mo¿e byæ zapisana w notacji naukowej. 
.B Liczba wymierna 
wygl±da jak dwie liczby
ca³kowite z kresk± u³amkow± / miêdzy nimi. LISP obs³uguje te¿ 
.BR liczby zespolone ,
które s±
zapisywane jako #c(r i) (gdzie r jest czê¶ci± rzeczywist±, a i jest czê¶ci±
urojon±). Liczb± jest dowolny zapis z powy¿szych. Przyk³ady:
.nf
.sp
        5
        17
        -34
        +6
        3.1415
        1.722e-15
        #c(1.722e-15 0.75)
.fi

Standardowe funkcje arytmetyczne s± wci±¿ dostêpne: 
.BR + ", " - ", " * ", " / ", " floor ", " ceiling ", " mod ", " sin ", "
.BR cos ", " tan ", " sqrt ", " exp ", " expt ", itd."
Wszystkie one przyjmuj± dowolny rodzaj argumentu. +, -, * i / zwracaj±
liczbê zgodnie z nastêpuj±cymi zasadami: liczba ca³kowita plus wymierna daje
wymiern±, wymierna plus rzeczywist± daje rzeczywist±, a rzeczywista plus
zespolona daje zespolon±. Oto przyk³ady:
.nf
.sp
> (+ 3 3/4)             ;determinacja typu wynikowego
15/4 
> (exp 1)               ;e
2.7182817 
> (exp 3)               ;e*e*e
20.085537 
> (expt 3 4.2)          ;potêga o podstawie innej ni¿ e
100.90418
> (+ 5 6 7 (* 8 9 10))  ;funkcje +-*/ przyjmuj± argumenty wielokrotne
.\" FIXME - chyba tu brakuje wyniku.... (rl, 28.05.2003)
.fi

Nie ma ograniczeñ w absolutnej warto¶ci liczby ca³kowitej, poza rozmiarem
pamiêci komputera. Ostrzegam jednak, ¿e obliczenia na du¿ych liczbach mog±
byæ wolne. (Podobnie jak obliczenia na liczbach wymiernych, szczególnie w
porównaniu do obliczeñ na ma³ych liczbach ca³kowitych lub rzeczywistych.)

.SH Wagoniki (ang. conses)

.B Wagonik 
jest zwyk³ym dwuelementowym rekordem. Z przyczyn historycznych jego pola
s± nazywane "\fBcar\fR" i "\fBcdr\fR". (Na pierwszej maszynie, na której
zaimplementowano LISP istnia³y dwie instrukcje, CAR i CDR, które oznacza³y
"contents of address register" i "contents of decrement register".
Wagoniki by³y zaimplementowane przy u¿yciu tych rejestrów.)

Wagoniki s± ³atwe w u¿yciu:
.nf
.sp
> (cons 4 5)            ;Zaalokuj wagonik. Ustaw car na 4 a cdr na 5.
(4 . 5)
> (cons (cons 4 5) 6)
((4 . 5) . 6)
> (car (cons 4 5))
4
> (cdr (cons 4 5))
5
.fi

.SH Listy

Z wagoników mo¿na budowaæ wiele struktur. Pewnie najprostsz± jest 
.BR "lista powi±zana" : 
car ka¿dego wagonika wskazuje na jeden z elementów listy, a cdr albo
na nastêpny element, albo na nil. Mo¿esz stworzyæ tak± powi±zan± listê przy
u¿yciu funkcji list:
.nf
.sp
> (list 4 5 6)
(4 5 6)
.fi

Zauwa¿, ¿e LISP drukuje powi±zane listy w szczególny sposób: pomija niektóre
kropki i nawiasy. Zasada jest taka: je¶li cdr wagonika to nil, LISP nie drukuje
kropki, ani nil; je¶li cdr wagonika A to wagonik B, to nie drukuje kropki dla
wagonika A, ani nawiasów dla wagonika B. Wiêc:
.nf
.sp
> (cons 4 nil)
(4)
> (cons 4 (cons 5 6))
(4 5 . 6)
> (cons 4 (cons 5 (cons 6 nil)))
(4 5 6)
.fi

Ostatni przyk³ad jest równowa¿ny dok³adnie wywo³aniu (list 4 5 6). Zauwa¿,
¿e nil oznacza teraz listê bez elementów: cdr listy 2 elementowej (a b) to (b),
lista o jednym elemencie; cdr 1 elementowego (b) to nil, który jest list± bez 
elementów.

Pusty (nil) car i cdr jest definiowany jako `nil'.

Je¶li zapisujesz swoj± listê w zmiennej, mo¿esz spowodowaæ, ¿e bêdzie dzia³aæ
jak stos:
.nf
.sp
> (setq a nil)
NIL
> (push 4 a)
(4)
> (push 5 a)
(5 4)
> (pop a)
5
> a
(4)
> (pop a)
4
> (pop a)
NIL
> a
NIL
.fi

.SH Funkcje

Powy¿ej by³ przyk³ad funkcji. Oto kilka innych:
.nf
.sp
> (+ 3 4 5 6)                  ;ta funkcja pobiera dowoln± liczbê argumentów
18
> (+ (+ 3 4) (+ (+ 4 5) 6))    ;czy notacja przedrostkowa nie jest super?
22
> (defun foo (x y) (+ x y 5))  ;definiowanie funkcji
FOO
> (foo 5 0)                    ;wo³anie funkcji
10
> (defun fact (x)              ;funkcja rekursywna
    (if (> x 0) 
      (* x (fact (- x 1)))
      1
  ) )
FACT
> (fact 5)
120
> (defun a (x) (if (= x 0) t (b (- x))))    ;funkcje wzajemnie rekurencyjne
A
> (defun b (x) (if (> x 0) (a (- x 1)) (a (+ x 1))))
B
> (a 5)
T
> (defun bar (x)                ;funkcja o wielu instrukcjach w swoim
    (setq x (* x 3))            ;ciele -- zwróci warto¶æ, zwracan± przez
    (setq x (/ x 2))            ;jej ostatni± instrukcjê
    (+ x 4)
  )
BAR
> (bar 6)
13
.fi

Gdy zdefiniowali¶my `foo', nadali¶my mu dwa argumenty, `x' i `y'. Teraz, gdy
wo³amy `foo', musimy podaæ dok³adnie dwa argumenty: pierwszy stanie siê na
czas wywo³ania warto¶ci± `x', a drugi stanie siê warto¶ci± `y'.
W lispie wiêkszo¶æ zmiennych jest zawê¿ona leksykalnie; to znaczy je¶li
`foo' wo³a `bar', a `bar' próbuje odnie¶æ siê do `x', to nie jest to mo¿liwe.

Proces przyznawania symbolowi warto¶ci na czas zawê¿eñ leksykalnych jest
nazywany 
.B wi±zaniem 
(binding).

Dla swoich funkcji mo¿esz podawaæ argumenty dodatkowe. Ka¿dy argument po
symbolu \fB&optional\fR jest opcjonalny:
.nf
.sp
> (defun bar (x &optional y) (if y x 0))
BAR
> (defun baaz (&optional (x 3) (z 10)) (+ x z))
BAAZ
> (bar 5)
0
> (bar 5 t)
5
> (baaz 5)
15
> (baaz 5 6)
11
> (baaz)
13
.fi

Funkcjê `bar' mo¿na wywo³aæ z jednym lub dwoma argumentami. Po wywo³aniu z
jednym argumentem, warto¶æ `x' jest ustawiana normalnie, natomiast `y' jest
ustawiane na `nil'. Po wywo³aniu z dwoma argumentami, warto¶æ `x' i `y' 
zostanie odpowiednio nimi zainicjalizowana.

Funkcja `baaz' ma dwa argumenty opcjonalne. Dla ka¿dego z nich daje warto¶æ
domy¶ln±: je¶li wo³aj±cy poda tylko jeden argument, `z' zostanie zwi±zane nie
z `nil', lecz z 10, a gdy wo³aj±cy w ogóle nie poda argumentów, `x' zostanie
powi±zany z 3, a `z' z 10.

Mo¿esz spowodowaæ, ¿e funkcja przyjmuje dowoln± liczbê argumentów, koñcz±c
jej argument parametrem \fB&rest\fR. LISP wtedy zbierze wszystkie argumenty do
listy i przywi±¿e j± do parametru &rest.
.nf
.sp
> (defun foo (x &rest y) y)
FOO
> (foo 3)
NIL
> (foo 4 5 6)
(5 6)
.fi

W koñcu, mo¿esz podaæ swojej funkcji dowolny rodzaj argumentu opcjonalnego,
zwanego 
.BR "argumentem s³owa kluczowego" . 
Wo³aj±cy mo¿e podawaæ takie argumenty w dowolnej kolejno¶ci--s± one 
etykietowane s³owami kluczowymi.
.nf
.sp
> (defun foo (&key x y) (cons x y))
FOO
> (foo :x 5 :y 3)
(5 . 3)
> (foo :y 3 :x 5)
(5 . 3)
> (foo :y 3)
(NIL . 3)
> (foo)
(NIL)
.fi

Parametr \fB&key\fR mo¿e mieæ równie¿ warto¶æ domy¶ln±:
.nf
.sp
> (defun foo (&key (x 5)) x)
FOO
> (foo :x 7)
7
> (foo)
5
.fi

.SH Drukowanie

Niektóre funkcje mog± przesy³aæ dane na wyj¶cie. Najprostsz± jest \fBprint\fR,
która drukuje swój argument i zwraca go.
.nf
.sp
> (print 3)
3
3
.fi

Pierwsze 3 zosta³o wydrukowane, drugie zwrócone.

Je¶li oczekujesz bardziej z³o¿onego wyj¶cia, musisz u¿yæ formatu. Oto
przyk³ad:
.nf
.sp
> (format t "An atom: ~S~%and a list: ~S~%and an integer: ~D~%"
          nil (list 5) 6)
An atom: NIL
and a list: (5)
and an integer: 6
.fi

Pierwszy argument instrukcji format to `t', `nil' lub strumieñ. `T' wskazuje 
na wyj¶cie na terminal. `Nil' oznacza, ¿e niczego nie mo¿na drukowaæ, a nale¿y
zamiast tego powróciæ do ³añcucha zawieraj±cego wyj¶cie. Strumienie s±
ogólnymi miejscami przep³ywu wyj¶cia: wskazuj± na pliki, terminale lub inne
programy. Ten podrêcznik nie bêdzie siê dok³adniej zajmowa³ strumieniami.

Kolejnym argumentem jest \fImatryca formatuj±ca\fR, która jest ³añcuchem
opcjonalnie zawieraj±cym dyrektywy formatuj±ce.

Wszystkie pozosta³e argumenty mog± byæ u¿ywane przez dyrektywy formatuj±ce.
LISP zamieni dyrektywy na odpowiednie znaki, w oparciu argumenty, do których
(dyrektywy) siê one odnosz±. Nastêpnie ³añcuch zostanie wydrukowany.

Format zawsze zwraca `nil', chyba ¿e jego pierwszym argumentem jest `nil'--wtedy
nic nie drukuje i zwraca ³añcuch.

W powy¿szym przyk³adzie istniej± trzy ró¿ne dyrektywy:
.BR ~S ", " ~D " i " ~% ". " 
Pierwsza przyjmuje dowolny obiekt LISP i jest zamieniana drukowaln± 
reprezentacj± tego obiektu (tak± sam±, jak produkowana przez \fBprint\fR). 
Druga przyjmuje tylko liczby ca³kowite. Ostatnia nie odnosi siê do argumentu. 
Jest zawsze zamieniana na powrót karetki.

Inn± przydatn± dyrektyw± jest \fB~~\fR, która jest zamieniana na pojedyncz± `~'.

Zajrzyj do podrêcznika LISP, s± tam ró¿ne inne dyrektywy formatuj±ce.

.SH Formy i pêtla g³ówna

Wszystko, co wpisujesz do interpretera LISP okre¶lane jest mianem \fBform\fR;
interpreter odczytuje tak± formê, analizuje j± i drukuje wynik. Procedura ta
jest nazywana pêtl± odczytu-analizy-drukowania.

Niektóre formy mog± dawaæ b³êdy. Po b³êdzie, LISP przerzuci ciê do
debuggera, aby¶ móg³ znale¼æ b³±d. Ka¿dy debugger LISP jest inny; jednak
wiêkszo¶æ z nich odpowiada na komendê "\fBhelp\fR" lub "\fB:help\fR".

Ogólnie, form± jest zarówno atom (np. symbol, liczba ca³kowita, ³añcuch) jak 
lista. Je¶li forma jest atomem, LISP analizuje j± natychmiast. Je¶li jest
list±, to jej pierwszy element jest traktowany jak nazwa funkcji; pozosta³e
elementy analizowane s± rekurencyjnie i wywo³uje siê tê funkcjê z warto¶ciami
pozosta³ych elementów jako argumentami.

Na przyk³ad, je¶li LISP widzi formê \fI(+ 3 4)\fR, traktuje `+' jako nazwê 
funkcji. Potem analizuje 3 aby pobraæ 3 i 4 aby pobraæ 4; w koñcu wo³a `+' z
argumentami 3 i 4. Funkcja `+' zwraca 7, co jest drukowane jako wynik.

Pêtla g³ówna daje inne udogodnienia; szczególnie wygodn± rzecz± jest
mo¿liwo¶æ mówienia o wynikach poprzednio wpisanych form. LISP zawsze
udostêpnia swoje trzy naj¶wie¿sze wyniki; kryj± siê one pod 
symbolami \fB*\fR, \fB**\fR i \fB***\fR. Na przyk³ad:
.nf
.sp
> 3
3
> 4
4
> 5
5
> ***
3
> ***
4
> ***
5
> **
4
> *
4
.fi

.SH Formy specjalne

Istnieje pewna liczba form specjalnych, które wygl±daj± jak wywo³ania
funkcji, lecz nimi nie s±. Zaliczaj± siê do nich konstrukcje steruj±ce,
takie jak instrukcje \fBif\fR i pêtle \fBdo\fR; przypisania takie jak 
.BR setq ", " setf ", " push " i " pop "; " 
definicje takie, jak 
.BR defun i defstruct "; " 
a tak¿e konstrukcje wi±¿±ce, takie jak \fBlet\fR. (Nie wszystkie te formy 
zosta³y ju¿ wymienione. Patrz ni¿ej.)

Jedn± przydatn± form± specjaln± jest forma cytowania (\fBquote\fR): chroni ona
argument przed zanalizowaniem. Na przyk³ad:
.nf
.sp
> (setq a 3)
3
> a
3
> (quote a)
A
> 'a                    ;'a jest skrótem dla (quote a)
A
.fi

Inn± prost± form± specjaln± jest forma funkcji (\fBfunction\fR): powoduje, ¿e 
jej argument jest interpretowany jako funkcja:
.nf
.sp
> (setq + 3)
3
> +
3
> '+
+
> (function +)
#<Function + @ #x-fbef9de>
> #'+                   ;#'+ jest skrótem dla (function +)
#<Function + @ #x-fbef9de>
.fi

Ta forma specjalna jest przydatna gdy chcesz przekazaæ funkcjê jako argument
do innej funkcji. Ni¿ej s± przyk³ady funkcji, bior±cych argumenty
funkcyjne.

.SH Wi±zanie

Wi±zanie to zawê¿one leksykalnie przypisanie. Zachodzi na zmiennych w li¶cie
parametrów funkcji za ka¿dym wywo³aniem funkcji: formalne parametry s±
wi±zane do rzeczywistych parametrów na czas wywo³ania funkcji. Zmienne mo¿na
wi±zaæ w dowolnym miejscu programu, u¿ywaj±c specjalnej formy \fBlet\fR, która
wygl±da tak:
.nf
.sp
        (let ((var1 val1)
              (var2 val2)
              ...
             )
          body
        )
.fi

`Let' wi±¿e `var1' do `val1' i `var2' do `val2' (i tak dalej); potem wykonuje
instrukcje swojego cia³a. Cia³o `let' podpada pod dok³adnie te same regu³y, co
cia³o funkcji. Przyk³ady:
.nf
.sp
> (let ((a 3)) (+ a 1))
4
> (let ((a 2) 
        (b 3)
        (c 0))
    (setq c (+ a b))
    c
  )
5
> (setq c 4)
4
> (let ((c 5)) c)
5
> c
4
.fi

Zamiast \fI(let ((a nil) (b nil)) ...)\fR, mo¿esz napisaæ \fI(let (a b) ...)\fR.

`Val1', `val2', itd. wewn±trz `let' nie mog± odnosiæ siê do zmiennych `var1',
`var2', itd., które s± wi±zane. Na przyk³ad
.nf
.sp
> (let ((x 1)
        (y (+ x 1)))
    y
  )
Error: Attempt to take the value of the unbound symbol X
.fi

Je¶li symbol `x' ju¿ ma warto¶æ globaln±, wynikiem bêd± dziwne zdarzenia:
.nf
.sp
> (setq x 7)
7
> (let ((x 1)
        (y (+ x 1)))
    y
  )
8
.fi

Forma specjalna \fBlet*\fR jest podobna do `let', lecz zezwala warto¶ciom na
wskazywanie na zmienne, zdefiniowane w `let' wcze¶niej. Na przyk³ad:
.nf
.sp
> (setq x 7)
7
> (let* ((x 1)
         (y (+ x 1)))
    y
  )
2
.fi

Forma
.nf
.sp
        (let* ((x a)
               (y b))
          ...
        ) 
.fi

jest równowa¿na
.nf
.sp
        (let ((x a))
          (let ((y b))
            ...
        ) )
.fi

.SH Zakresy dynamiczne

Formy `let' i `let*' daj± zawê¿anie leksykalne, które jest rzecz±, do której
mog³e¶ siê przyzwyczaiæ w C lub Pascalu. Zakresy (zawê¿anie) dynamiczne s±
popularne w BASIC-u: je¶li przypiszesz warto¶æ zmiennej dynamicznej, ka¿de
wspomnienie tej zmiennej zwraca nadan± warto¶æ, a¿ nie przyznasz nowej.

W LISP-ie, zmienne dynamicznego zakresu s± nazywane zmiennymi specjalnymi.
Mo¿esz je deklarowaæ w formie \fBdefvar\fR. Oto przyk³ady zmiennych dynamicznie 
i leksykalnie zawê¿anych.

W tym przyk³adzie, funkcja `check-regular' odnosi siê do zmiennej `regular'
(np. leksykalnej). Poniewa¿ `check-regular' jest leksykalnie poza `let', który
wi±¿e `regular', `check-regular' zwraca globaln± warto¶æ zmiennej.
.nf
.sp
> (setq regular 5)
5 
> (defun check-regular () regular)
CHECK-REGULAR 
> (check-regular)
5 
> (let ((regular 6)) (check-regular))
5 
.fi

W tym przyk³adzie, funkcja `check-special' odnosi siê do zmiennej `special' (np.
dynamicznie zawê¿onej). Poniewa¿ wywo³anie `check-special' jest tymczasowo
wewn±trz `let', który wi±¿e `special', `check-special' zwraca lokaln± warto¶æ
zmiennej.
.nf
.sp
> (defvar *special* 5)
*SPECIAL*
> (defun check-special () *special*)
CHECK-SPECIAL
> (check-special)
5
> (let ((*special* 6)) (check-special))
6
.fi

Tradycyjnie, nazwa zmiennej specjalnej rozpoczyna siê od `*'. Zmienne
specjalne s± u¿ywane g³ównie jako zmienne globalne, gdy¿ programi¶ci
zazwyczaj oczekuj± dla zmiennych lokalnych zawê¿ania leksykalnego, a dla
globalnych dynamicznego.

Dla dalszych informacji o ró¿nicach miêdzy zawê¿eniami leksykalnymi i
dynamicznymi, zobacz \fBCommon LISP: the Language\fR.

.SH Tablice

Funkcja \fBmake-array\fR tworzy tablicê. Funkcja \fBaref\fR daje dostêp do 
jej elementów. Wszystkie elementy tablicy s± pocz±tkowo ustawione na `nil'. Na
przyk³ad:
.nf
.sp
> (make-array '(3 3))
#2a((NIL NIL NIL) (NIL NIL NIL) (NIL NIL NIL))
> (aref * 1 1)
NIL
> (make-array 4)        ;tablice 1D nie wymagaj± dodatkowych nawiasów
#(NIL NIL NIL NIL)
.fi

Indeksy tablic zawsze rozpoczynaj± siê od 0.

Jak ustawiaæ elementy tablicy, opisano ni¿ej.

.SH Napisy

.B Napis 
jest sekwencj± znaków w podwójnych cudzys³owach. W LISP napis jest
reprezentowany jako tablica znaków o zmiennej d³ugo¶ci. Napis zawieraj±cy
podwójne cudzys³owy mo¿na zapisaæ, poprzedzaj±c cudzys³ów znakiem lewego
uko¶nika; podwójny lewy uko¶nik oznacza pojedynczy lewy uko¶nik. Na
przyk³ad:
.nf
.sp
        "abcd" ma 4 znaki
        "\\"" ma 1 znak
        "\\\\" ma 1 znak
.fi

Oto kilka funkcji zajmuj±cych siê napisami:
.nf
.sp
> (concatenate 'string "abcd" "efg")
"abcdefg"
> (char "abc" 1)
#\\b                     ;LISP zapisuje znaki poprzedzone #\\
> (aref "abc" 1)
#\\b                     ;pamiêtaj, napisy w rzeczywisto¶ci s± tablicami
.fi

Funkcja \fBconcatenate\fR mo¿e w rzeczywisto¶ci dzia³aæ z dowolnym rodzajem
sekwencji:
.nf
.sp
> (concatenate 'string '(#\\a #\\b) '(#\\c))
"abc"
> (concatenate 'list "abc" "de")
(#\\a #\\b #\\c #\\d #\\e)
> (concatenate 'vector '#(3 3 3) '#(3 3 3))
#(3 3 3 3 3 3)
.fi

.SH Struktury

Struktury LISP s± analogiczne do struktur C lub rekordów Pascala. Oto
przyk³ad:
.nf
.sp
> (defstruct foo
    bar
    baaz
    quux
  )
FOO
.fi

Przyk³ad ten definiuje typ danych o nazwie `foo', który jest struktur±,
zawieraj±c± 3 pola. Definiuje te¿ 4 funkcje, które operuj± na tym typie
danych: \fBmake-foo\fR, \fBfoo-bar\fR, \fBfoo-baaz\fR i \fBfoo-quux\fR. 
Pierwsza tworzy nowy obiekt
typu `foo'; pozosta³e daj± dostêp do poszczególnych pól obiektu. Oto jak
u¿ywaæ tych funkcji:
.nf
.sp
> (make-foo)
#s(FOO :BAR NIL :BAAZ NIL :QUUX NIL) 
> (make-foo :baaz 3)
#s(FOO :BAR NIL :BAAZ 3 :QUUX NIL) 
> (foo-bar *)
NIL
> (foo-baaz **)
3
.fi

Funkcja `make-foo' mo¿e pobieraæ argument s³owa kluczowego dla ka¿dego pola
struktury `foo'. Funkcje dostêpu do pól pobieraj± jeden argument, strukturê
typu `foo' i zwracaj± odpowiedni± warto¶æ.

Zobacz ni¿ej jak ustawiæ pola struktury.

.SH Setf

Pewne formy w LISP-ie naturalnie definiuj± pozycjê w pamiêci. Na przyk³ad,
je¶li warto¶æ `x' jest struktur± typu `foo', to \fI(foo-bar x)\fR definiuje 
pole `bar' o warto¶ci `x'. Lub je¶li warto¶æ `y' jest jednowymiarow± tablic±, 
\fI(aref y 2)\fR definiuje trzeci element `y'.

Specjalna forma \fBsetf\fR u¿ywa swojego pierwszego argumentu do zdefiniowania
miejsca w pamiêci, analizuje drugi argument i zapisuje wynik w wynikowej
pozycji pamiêci. Na przyk³ad,
.nf
.sp
> (setq a (make-array 3))
#(NIL NIL NIL)
> (aref a 1)
NIL
> (setf (aref a 1) 3)
3
> a
#(NIL 3 NIL)
> (aref a 1)
3
> (defstruct foo bar)
FOO
> (setq a (make-foo))
#s(FOO :BAR NIL)
> (foo-bar a)
NIL
> (setf (foo-bar a) 3)
3
> a
#s(FOO :BAR 3)
> (foo-bar a)
3
.fi

.B Setf
jest jedynym sposobem na ustawianie pól struktury lub tablicy.

Oto kilka innych przyk³adów \fBsetf\fR i zwi±zanych z nim funkcji.
.nf
.sp
> (setf a (make-array 1))       ;setf na zmiennej jest równowa¿ne setq
#(NIL)
> (push 5 (aref a 1))           ;push mo¿e dzia³aæ jak setf
(5)
> (pop (aref a 1))              ;podobnie pop
5
> (setf (aref a 1) 5)
5
> (incf (aref a 1))             ;incf odczytuje z danego miejsca, 
6                               ;inkrementuje i zapisuje z powrotem.
> (aref a 1)
6
.fi

.SH Zmienne logiczne i warunki

LISP do oznaczania fa³szu u¿ywa symbolu `nil'. Wszystko inne ni¿ `nil' oznacza
prawdê. O ile nie mamy specjalnych powodów, dla prawdy u¿ywa siê symbolu `t'.

LISP daje standardowy zestaw funkcji logicznych, np. 
.BR and ", " or " i " not ". " And " i " or
s± blisko-zwieraj±ce: \fBand\fR nie zanalizuje ¿adnych argumentów na prawo od
pierwszego zrozumianego jako nil, a \fBor\fR nie zanalizuje ¿adnych argumentów 
na prawo od pierwszego, zrozumianego jako t.

LISP daje te¿ specjalne formy dla wyra¿eñ warunkowych. Najprostsz± jest
\fBif\fR. Pierwszy argument tej formy okre¶la czy wywo³aæ argument drugi, 
czy trzeci.
.nf
.sp
> (if t 5 6)
5
> (if nil 5 6)
6
> (if 4 5 6)
5
.fi

Je¶li potrzebujesz wiêcej ni¿ jednej instrukcji w klauzuli \fIthen\fR lub
\fIelse\fR \fBif\fR'a, to mo¿esz u¿yæ specjalnej formy \fBprogn\fR.
\fBProgn\fR wykonuje ka¿d± instrukcjê swojego cia³a i zwraca ostatni± warto¶æ.
.nf
.sp
> (setq a 7)
7
> (setq b 0)
0
> (setq c 5)
5
> (if (> a 5)
    (progn
      (setq a (+ b 7))
      (setq b (+ c 8)))
    (setq b 4)
  )
13
.fi

Instrukcja \fBif\fR, której brak klauzuli \fIthen\fR lub \fIelse\fR, mo¿e byæ 
zapisana przy u¿yciu specjalnej formy \fBunless\fR:
.nf
.sp
> (when t 3)
3
> (when nil 3)
NIL
> (unless t 3)
NIL
> (unless nil 3)
3
.fi

.BR When " i " unless 
w przeciwieñstwie do \fBif\fR, zezwalaj± na dowoln± liczbê
instrukcji w swoich cia³ach. (Np. \fI(when x a b c)\fR jest równowa¿ne \fI(if x
(progn a b c))\fR.
.nf
.sp
> (when t
    (setq a 5)
    (+ a 6)
  )
11
.fi

Bardziej z³o¿one warunki mo¿na definiuj±c przy u¿yciu formy specjalnej
\fBcond\fR która jest równowa¿na konstrukcji \fIif ... else if .. fi\fR.

\fBCond\fR sk³ada siê z symbolu `cond', za którym nastêpuj± \fI klauzule
cond\fR, z których
ka¿da jest list±. Pierwszy element \fIklauzuli cond\fR jest warunkiem; pozosta³e
elementy (je¶li istniej±) s± akcj±. Forma \fBcond\fR szuka pierwszej klauzuli,
której warunek jest spe³niony; potem wykonuje odpowiedni± akcjê i zwraca
warto¶æ wynikow±. ¯aden pozosta³y warunek nie jest ju¿ analizowany; nie s±
te¿ wykonywane inne akcje ni¿ ta, odpowiadaj±ca warunkowi. Na przyk³ad:
.nf
.sp
> (setq a 3)
3
> (cond
   ((evenp a) a)        ;je¶li a jest parzyste, zwróæ a
   ((> a 7) (/ a 2))    ;inaczej, je¶li a jest > ni¿ 7, zwróæ a/2
   ((< a 5) (- a 1))    ;inaczej, je¶li a jest < ni¿ 5, zwróæ a-1
   (t 17)               ;inaczej zwróæ 17
  )
2
.fi

Je¶li w danej klauzuli cond brakuje akcji, \fBcond\fR zwraca warto¶æ, do której
zosta³ zredukowany warunek:
.nf
.sp
> (cond ((+ 3 4)))
7
.fi

Oto ma³a sprytna rekurencyjna funkcja, u¿ywaj±ca cond. Mo¿esz spróbowaæ 
udowodniæ, ¿e koñczy siê dla wszystkich liczb ca³kowitych x wielko¶ci 
przynajmniej 1. (Je¶li ci siê uda, opublikuj rezultat.)
.nf
.sp
> (defun hotpo (x steps)        ;hotpo oznacza Half Or Triple Plus One
    (cond
     ((= x 1) steps)
     ((oddp x) (hotpo (+ 1 (* x 3)) (+ 1 steps)))
     (t (hotpo (/ x 2) (+ 1 steps)))
  ) )
A
> (hotpo 7 0)
16
.fi

Instrukcja \fBcase\fR w LISP jest podobna do instrukcji \fBswitch\fR w C:
.nf
.sp
> (setq x 'b)
B
> (case x
   (a 5)
   ((d e) 7)
   ((b f) 3)
   (otherwise 9)
  )
3
.fi

Klauzula \fBotherwise\fR oznacza, ¿e je¶li x nie jest a, b, d, e lub f, 
instrukcja \fBcase\fR ma zwróciæ 9.

.SH Iteracja

Najprostsz± konstrukcj± iteracyjn± w LISP jest pêtla (\fBloop\fR): konstrukcja
ta kolejno wykonuje swoje cia³a, a¿ nie natrafi na specjaln± formê
\fBreturn\fR. Na przyk³ad
.nf
.sp
> (setq a 4)
4
> (loop 
   (setq a (+ a 1))
   (when (> a 7) (return a))
  )
8
> (loop
   (setq a (- a 1))
   (when (< a 3) (return))
  )
NIL
.fi

Kolejn± najprostsz± jest \fBdolist\fR: wi±¿e ona zmienn± do elementów listy w
kolejno¶ci i koñczy gdy trafi na koniec listy.
.nf
.sp
> (dolist (x '(a b c)) (print x))
A 
B 
C 
NIL 
.fi

.B Dolist 
zawsze zwraca `nil'. Zauwa¿, ¿e warto¶æ `x' w powy¿szym przyk³adzie nigdy
nie by³a `nil': NIL znajduj±cy siê po C by³ warto¶ci± zwracan± przez
\fBdolist\fR, drukowan± przez pêtlê odczytu-analizy-drukowania.

Najbardziej skomplikowanym rodzajem iteracji jest \fBdo\fR. Instrukcja do 
wygl±da nastêpuj±co:
.nf
.sp
> (do ((x 1 (+ x 1))
       (y 1 (* y 2)))
      ((> x 5) y)
    (print y)
    (print 'working)
  )
1 
WORKING 
2 
WORKING 
4 
WORKING 
8 
WORKING 
16 
WORKING 
32 
.fi

Pierwsza czê¶æ `do' okre¶la, które zmienne nale¿y zwi±zaæ, jakie s± ich
warto¶ci pocz±tkowe i jak je od¶wie¿aæ. Nastêpna czê¶æ okre¶la warunek
zakoñczenia i warto¶æ zwracan±. Ostatni± czê¶ci± jest cia³o. Forma \fBdo\fR 
wi±¿e jak `let' swoje zmienne do warto¶ci pocz±tkowych, a potem sprawdza 
warunek zakoñcznia. Dopóki warunek jest fa³szywy, wykonuje cia³o; gdy 
warunek staje siê prawdziwy, zwraca warto¶æ formy \fBreturn-value\fR.

Forma \fBdo*\fR jest analogiczna do `let*' w `let'.

.SH Nielokalne wyj¶cia

Forma specjalna \fBreturn\fR, wspomniana w poprzedniej sekcji o iteracji jest
przyk³adem nielokalnego wyj¶cia. Innym przyk³adem jest forma
\fBreturn-form\fR, która zwraca warto¶æ z otaczaj±cej funkcji:
.nf
.sp
> (defun foo (x)
    (return-from foo 3)
    x
  )
FOO
> (foo 17)
3
.fi

W³a¶ciwie, forma \fBreturn-form\fR mo¿e zwróciæ warto¶æ z dowolnego nazwanego
bloku--po prostu funkcje s± jedynymi blokami, które s± domy¶lnie nazwane.
Blok nazwany mo¿esz tworzyæ specjaln± form± \fBblock\fR:
.nf
.sp
> (block foo
    (return-from foo 7)
    3
  )
7
.fi
Forma specjalna \fBreturn\fR mo¿e zwróciæ warto¶æ z dowolnego bloku o nazwie
`nil'.
Domy¶lnie przez nil oznaczane s± pêtle, lecz mo¿esz te¿ tworzyæ w³asne bloki
oznaczone `nil':
.nf
.sp
> (block nil
    (return 7)
    3
  )
7
.fi

Inn± form±, która powoduje nielokalne wyj¶cie jest forma \fBerror\fR:
.nf
.sp
> (error "This is an error")
Error: This is an error
.fi

Forma \fBerror\fR za³±cza format do swoich argumentów, a potem umieszcza ciê w
debuggerze.

.SH Funcall, Apply, i Mapcar

Wcze¶niej obieca³em, ¿e dam trochê funkcji, które jako argumenty pobieraj±
funkcje. Oto one:
.nf
.sp
> (funcall #'+ 3 4)
7
> (apply #'+ 3 4 '(3 4))
14
> (mapcar #'not '(t nil t nil t nil))
(NIL T NIL T NIL T)
.fi

.B Funcall 
wo³a swój pierwszy argument z pozosta³ymi argumentami.

.B Apply 
dzia³a podobnie do 
.BR funcall , 
lecz jej ostatni argument powinien byæ
list±; elementy tej listy s± traktowane tak, jakby by³y dodatkowymi
argumentami 
.BR funcall .

Pierwszy argument
.B mapcar 
musi byæ funkcj± jednoargumentow±; 
.B mapcar 
stosuje
t± funkcjê do ka¿dego elementu listy i zbiera wyniki w innej li¶cie.

.BR Funcall " i " apply 
s± u¿ywane czêsto gdy ich pierwszym argumentem jest zmienna.
Na przyk³ad mechanizm przeszukiwania mo¿e braæ jako parametr funkcjê
heurystyczn± i u¿ywaæ 
.BR funcall " lub " apply 
do wo³ania jej dla opisu stanu.
Funkcje sortowania, opisane dalej u¿ywaj± \fBfuncall\fR do wo³ania funkcji
porównawczych.

.B Mapcar 
wraz funkcjami bez nazwy (patrz ni¿ej) mo¿e zast±piæ wiele pêtli.

.SH Lambda

Je¶li chcesz utworzyæ funkcjê tymczasow± i nie chcesz nadawaæ jej nazwy, to
mo¿esz u¿yæ \fBlambda\fR.
.nf
.sp
> #'(lambda (x) (+ x 3))
(LAMBDA (X) (+ X 3))
> (funcall * 5)
8
.fi
Po³±czenie 
.BR lambda " i " mapcar 
mo¿e zast±piæ wiele pêtli. Na przyk³ad, nastêpuj±ce postacie s± równowa¿ne:
.nf
.sp
> (do ((x '(1 2 3 4 5) (cdr x))
       (y nil))
      ((null x) (reverse y))
    (push (+ (car x) 2) y)
  )
(3 4 5 6 7)
> (mapcar #'(lambda (x) (+ x 2)) '(1 2 3 4 5))
(3 4 5 6 7)
.fi

.SH Sortowanie

LISP daje do sortowania dwa prymitywy: 
.BR sort " i " stable-sort.
.nf
.sp
> (sort '(2 1 5 4 6) #'<)
(1 2 4 5 6)
> (sort '(2 1 5 4 6) #'>)
(6 5 4 2 1)
.fi

Pierwszym argumentem 
.B sort 
jest lista; drugim funkcja porównawcza. Funkcja
sortuj±ca nie gwarantuje stabilno¶ci: je¶li s± dwa elementy takie, ¿e
.I (and (not (< a b)) (not (< b a)))
\fR, to sort mo¿e zaaran¿owaæ je w dowolnym
porz±dku. Funkcja 
.BR stable-sort " jest taka sama jak " sort ", lecz gwarantuje, ¿e "
dwa równowa¿ne elementy pojawi± siê w li¶cie posortowanej w tej samej
kolejno¶ci co na li¶cie wej¶ciowej.

Uwaga: 
.B sort 
mo¿e niszczyæ swój argument, wiêc je¶li sekwencja wej¶ciowa jest
dla ciebie wa¿na, utwórz jej kopiê poleceniem 
.BR copy " lub " copy-list " czy " copy-seq ". "

.SH Równo¶æ

LISP ma wiele ró¿nych wizji równo¶ci. Równo¶æ numeryczna jest oznaczana
przez \fB=\fR. Dwa symbole s± \fBeq\fR tylko gdy s± identyczne. Dwie kopie 
tej samej listy nie s± \fBeq\fR, choæ s± równe.
.nf
.sp
> (eq 'a 'a)
T
> (eq 'a 'b)
NIL
> (= 3 4)
T
> (eq '(a b c) '(a b c))
NIL
> (equal '(a b c) '(a b c))
T
> (eql 'a 'a)
T
> (eql 3 3)
T
.fi

.B Eql 
jest równowa¿ny 
.B eq 
dla symboli i 
.B = 
dla liczb.

.B Equal jest równowa¿ny 
.B eql 
dla symboli i liczb. Jest prawdziwy dla dwóch
wagoników tylko gdy ich car-y i cdr-y s± sobie równe. Jest prawdziwy dla
dwóch struktur tylko gdy wszystkie ich pola s± sobie równe.

.SH Przydatne funkcje listowe

Oto funkcje, dzia³aj±ce na listach.
.nf
.sp
> (append '(1 2 3) '(4 5 6))    ;³±cz (konkatenuj) listy
(1 2 3 4 5 6)
> (reverse '(1 2 3))            ;odwróæ elementy listy
(3 2 1)
> (member 'a '(b d a c))        ;ustaw cz³onkowstwo--zwraca pierwszy ogon
(A C)                           ;w którym car jest ¿±danym elemetem.
> (find 'a '(b d a c))          ;inny sposób ustawiania cz³onkowstwa
A
> (find '(a b) '((a d) (a d e) (a b d e) ()) :test #'subsetp)
(A B D E)                       ;find jest jednak bardziej elastyczny
> (subsetp '(a b) '(a d e))     ;zawieranie siê zbiorów
NIL
> (intersection '(a b c) '(b))  ;przekrój zbiorów
(B)
> (union '(a) '(b))             ;suma zbiorów
(A B)
> (set-difference '(a b) '(a))  ;ró¿nica zbiorów
(B)
.fi

.BR Subsetp ", " intersection ", " union " i " set-difference 
zak³adaj±, ¿e ¿aden z argumentów nie posiada zduplikowanych elementów. Np.
.I (subsetp '(a a) '(a b b)) 
mo¿e siê nie powie¶æ.

.BR Find ", " subsetp ", " intersection ", " union " i " set-difference 
mog± braæ argument o s³owie kluczowym \fI:test\fR; domy¶lnie wszystkie 
u¿ywaj± \fBeql\fR.

.SH Pocz±tki z Emacsem

Do edycji kodu LISP mo¿esz u¿ywaæ Emacsa: wiêkszo¶æ Emacsów jest
skonfigurowania na wchodzenie w tryb LISP za ka¿dym razem gdy znajd± plik,
koñcz±cy siê na \fI.lisp\fR. Je¶li u ciebie tak siê nie dzieje, wpisz
\fBM-x lisp-mode\fR.

Pod Emacsem mo¿esz te¿ uruchamiaæ LISP: upewnij siê, ¿e masz w ¶cie¿ce
komendê o nazwie lisp, która uruchamia twojego ulubionego LISP-a. Na
przyk³ad mo¿esz wpisaæ
.nf
.sp
        ln -s /usr/local/bin/clisp ~/bin/lisp
.fi

Potem, w Emacsie wpisz \fBM-x run-lisp\fR. Mo¿esz wtedy wys³aæ kod LISP do
interpretera i zrobiæ wiele innych fajnych rzeczy; dla dalszych informacji
wpisz \fBC-h m\fR z dowolnego bufora w trybie LISP.

W rzeczywisto¶ci nawet nie musisz tworzyæ dowi±zania. Emacs ma zmienn± o
nazwie \fBinferior-lisp-program\fR; wiêc je¶li dodasz liniê
.nf
.sp
        (setq inferior-lisp-program "/usr/local/bin/clisp")
.fi

do swojego pliku \fI.emacs\fR, to Emacs bêdzie wiedzia³ gdzie szukaæ CLISP-a 
dla komendy \fBM-x run-lisp\fR.

.SH AUTORZY
Geoffrey J. Gordon <ggordon@cs.cmu.edu> (pi±tek, 5 lutego 1993).
Poprawione przez Brunona Haible'a
<haible@ma2s2.mathematik.uni-karlsruhe.de>.
Przet³umaczone na jêzyk polski i przekonwertowane do postaci man przez
Przemka Borysa <pborys@dione.ids.pl>
